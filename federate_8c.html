<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: core/federated/federate.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">reactor-c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li><li class="navelem"><a class="el" href="dir_da79f73d8cf16fc09c9e3a52dcc440a7.html">federated</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">federate.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;sys/socket.h&gt;</code><br />
<code>#include &lt;netinet/in.h&gt;</code><br />
<code>#include &lt;arpa/inet.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;netdb.h&gt;</code><br />
<code>#include &lt;strings.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;signal.h&gt;</code><br />
<code>#include &quot;<a class="el" href="net__util_8c.html">net_util.c</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="net__common_8h_source.html">net_common.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="reactor_8h_source.html">../reactor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="platform_8h_source.html">../platform.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="scheduler_8h_source.html">../threaded/scheduler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="clock-sync_8c.html">clock-sync.c</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="federate_8h_source.html">federate.h</a>&quot;</code><br />
<code>#include &quot;regex.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0ed912257c1b82c7727c549aec8f3a73"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a0ed912257c1b82c7727c549aec8f3a73">listen_to_federates</a> (void *args)</td></tr>
<tr class="separator:a0ed912257c1b82c7727c549aec8f3a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d69c653591a4991b35ffd314ac7aad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a99d69c653591a4991b35ffd314ac7aad">send_neighbor_structure_to_RTI</a> (int rti_socket)</td></tr>
<tr class="separator:a99d69c653591a4991b35ffd314ac7aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2425b519aae66167fbf454f896df92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a0e2425b519aae66167fbf454f896df92">create_server</a> (int specified_port)</td></tr>
<tr class="separator:a0e2425b519aae66167fbf454f896df92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f0bc068b7a7c4a30983172eea59767"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a76f0bc068b7a7c4a30983172eea59767">send_message</a> (int message_type, unsigned short port, unsigned short federate, const char *next_destination_str, size_t length, unsigned char *message)</td></tr>
<tr class="separator:a76f0bc068b7a7c4a30983172eea59767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6916d42278d4c199272aaa884a1e01f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#ad6916d42278d4c199272aaa884a1e01f">send_timed_message</a> (<a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> additional_delay, int message_type, unsigned short port, unsigned short federate, const char *next_destination_str, size_t length, unsigned char *message)</td></tr>
<tr class="separator:ad6916d42278d4c199272aaa884a1e01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4711eb58251a2226c8b4f8be7c0d32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#afd4711eb58251a2226c8b4f8be7c0d32">_lf_send_time</a> (unsigned char type, <a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a> time, <a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> exit_on_error)</td></tr>
<tr class="separator:afd4711eb58251a2226c8b4f8be7c0d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3855de7f23c702c8d98e6cd88e6be15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#ab3855de7f23c702c8d98e6cd88e6be15">_lf_send_tag</a> (unsigned char type, <a class="el" href="structtag__t.html">tag_t</a> tag, <a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> exit_on_error)</td></tr>
<tr class="separator:ab3855de7f23c702c8d98e6cd88e6be15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2743dda029c873192d2cbad5170c252"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#ab2743dda029c873192d2cbad5170c252">handle_p2p_connections_from_federates</a> (void *ignored)</td></tr>
<tr class="separator:ab2743dda029c873192d2cbad5170c252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74e4453a091929855ab82a38074150e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#ab74e4453a091929855ab82a38074150e">_lf_close_outbound_socket</a> (int fed_id)</td></tr>
<tr class="separator:ab74e4453a091929855ab82a38074150e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48114c777d79a6c8ba5611414dc2581"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#ab48114c777d79a6c8ba5611414dc2581">listen_for_upstream_messages_from_downstream_federates</a> (void *fed_id_ptr)</td></tr>
<tr class="separator:ab48114c777d79a6c8ba5611414dc2581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca619f14cb3f3e777c8ca2e0e9ec022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a2ca619f14cb3f3e777c8ca2e0e9ec022">connect_to_federate</a> (uint16_t remote_federate_id)</td></tr>
<tr class="separator:a2ca619f14cb3f3e777c8ca2e0e9ec022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fb5cd6e02f70979dd3e30310d4b2bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#ac4fb5cd6e02f70979dd3e30310d4b2bb">connect_to_rti</a> (char *hostname, int port)</td></tr>
<tr class="separator:ac4fb5cd6e02f70979dd3e30310d4b2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc9f1bfb95d8b6c852a52832a9ecd9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#aacc9f1bfb95d8b6c852a52832a9ecd9e">get_start_time_from_rti</a> (<a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a> my_physical_time)</td></tr>
<tr class="separator:aacc9f1bfb95d8b6c852a52832a9ecd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f108cab37717071993e6e76efc83d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtrigger__t.html">trigger_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a89f108cab37717071993e6e76efc83d7">_lf_action_for_port</a> (int port_id)</td></tr>
<tr class="separator:a89f108cab37717071993e6e76efc83d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a55f84538e1d96832c6247d74e7da6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a26a55f84538e1d96832c6247d74e7da6">set_network_port_status</a> (int portID, <a class="el" href="reactor_8h.html#a759ba374f75ea0025b9af1bb35f14d7e">port_status_t</a> status)</td></tr>
<tr class="separator:a26a55f84538e1d96832c6247d74e7da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d570a16cab26d91c4b47fa5dd6ef6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a07d570a16cab26d91c4b47fa5dd6ef6a">mark_all_unknown_ports_as_absent</a> ()</td></tr>
<tr class="separator:a07d570a16cab26d91c4b47fa5dd6ef6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943c3d7aa45a6af5b6d1567cd4ce841c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a943c3d7aa45a6af5b6d1567cd4ce841c">is_input_control_reaction_blocked</a> ()</td></tr>
<tr class="separator:a943c3d7aa45a6af5b6d1567cd4ce841c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0858ebda70e9bc60f76b9d2aa3df39ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a0858ebda70e9bc60f76b9d2aa3df39ef">update_last_known_status_on_input_ports</a> (<a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="separator:a0858ebda70e9bc60f76b9d2aa3df39ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f7065af94169d68152aa9db4a15cc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#aa9f7065af94169d68152aa9db4a15cc5">update_last_known_status_on_input_port</a> (<a class="el" href="structtag__t.html">tag_t</a> tag, int port_id)</td></tr>
<tr class="separator:aa9f7065af94169d68152aa9db4a15cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89b0ab26ec13c6deafeb05c3c14a88e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#af89b0ab26ec13c6deafeb05c3c14a88e">reset_status_fields_on_input_port_triggers</a> ()</td></tr>
<tr class="separator:af89b0ab26ec13c6deafeb05c3c14a88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92ed203ebed8e9d8a3727d9b2583c56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#ad92ed203ebed8e9d8a3727d9b2583c56">mark_control_reaction_waiting</a> (int portID, <a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> waiting)</td></tr>
<tr class="separator:ad92ed203ebed8e9d8a3727d9b2583c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123194949f44242acbab252bc1ffed4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor_8h.html#a759ba374f75ea0025b9af1bb35f14d7e">port_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a123194949f44242acbab252bc1ffed4f">get_current_port_status</a> (int portID)</td></tr>
<tr class="separator:a123194949f44242acbab252bc1ffed4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a8a94cd5637607e88ef32abaa2dc5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a85a8a94cd5637607e88ef32abaa2dc5b">enqueue_network_input_control_reactions</a> ()</td></tr>
<tr class="separator:a85a8a94cd5637607e88ef32abaa2dc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892e175b19f257b58dec838106b898ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a892e175b19f257b58dec838106b898ad">enqueue_network_output_control_reactions</a> ()</td></tr>
<tr class="separator:a892e175b19f257b58dec838106b898ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa295d4779f0b5929a9bff7226f29e521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#aa295d4779f0b5929a9bff7226f29e521">enqueue_network_control_reactions</a> ()</td></tr>
<tr class="separator:aa295d4779f0b5929a9bff7226f29e521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a188ed34f9cf3a6d2ede7a033089bdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a4a188ed34f9cf3a6d2ede7a033089bdd">send_port_absent_to_federate</a> (<a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> additional_delay, unsigned short port_ID, unsigned short fed_ID)</td></tr>
<tr class="separator:a4a188ed34f9cf3a6d2ede7a033089bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e0b0634806dadc6bda729c63dc700f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#af4e0b0634806dadc6bda729c63dc700f">wait_until_port_status_known</a> (int port_ID, <a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> STP)</td></tr>
<tr class="separator:af4e0b0634806dadc6bda729c63dc700f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7ce364ced211e3892f71c47cff125c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor_8h.html#a3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a7e7ce364ced211e3892f71c47cff125c">schedule_message_received_from_network_already_locked</a> (<a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="structtag__t.html">tag_t</a> tag, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:a7e7ce364ced211e3892f71c47cff125c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48351e45d74393e322780dfeabad776"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#ad48351e45d74393e322780dfeabad776">_lf_request_close_inbound_socket</a> (int fed_id)</td></tr>
<tr class="separator:ad48351e45d74393e322780dfeabad776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f25989edc5bf8e0c8bf46efe9310d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a89f25989edc5bf8e0c8bf46efe9310d0">_lf_close_inbound_socket</a> (int fed_id)</td></tr>
<tr class="separator:a89f25989edc5bf8e0c8bf46efe9310d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5875ee5db1e60f40b6dd8c98f3eec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a3a5875ee5db1e60f40b6dd8c98f3eec3">handle_port_absent_message</a> (int socket, int fed_id)</td></tr>
<tr class="separator:a3a5875ee5db1e60f40b6dd8c98f3eec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a059641cbcf0e192594ea898cd09983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a8a059641cbcf0e192594ea898cd09983">handle_message</a> (int socket, int fed_id)</td></tr>
<tr class="separator:a8a059641cbcf0e192594ea898cd09983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe62a8b474897e95ba73528ffa23b621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#afe62a8b474897e95ba73528ffa23b621">handle_tagged_message</a> (int socket, int fed_id)</td></tr>
<tr class="separator:afe62a8b474897e95ba73528ffa23b621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7853e005f220474d4ce35be7a6560b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a7853e005f220474d4ce35be7a6560b2f">handle_tag_advance_grant</a> ()</td></tr>
<tr class="separator:a7853e005f220474d4ce35be7a6560b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77aa8325df62cb64364fb8af6b1c2334"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a77aa8325df62cb64364fb8af6b1c2334">_lf_logical_tag_complete</a> (<a class="el" href="structtag__t.html">tag_t</a> tag_to_send)</td></tr>
<tr class="separator:a77aa8325df62cb64364fb8af6b1c2334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d3825f70289972e7f2ab9fed3b24f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#ab1d3825f70289972e7f2ab9fed3b24f4">handle_provisional_tag_advance_grant</a> ()</td></tr>
<tr class="separator:ab1d3825f70289972e7f2ab9fed3b24f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ec02f52c1a7db4c7bdbc2871eae636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a60ec02f52c1a7db4c7bdbc2871eae636">_lf_fd_send_stop_request_to_rti</a> ()</td></tr>
<tr class="separator:a60ec02f52c1a7db4c7bdbc2871eae636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295baf41cee4f9450aaf7c95abede7e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a295baf41cee4f9450aaf7c95abede7e8">handle_stop_granted_message</a> ()</td></tr>
<tr class="separator:a295baf41cee4f9450aaf7c95abede7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe22b3d14b1992c6981d2cfcb89c425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a5fe22b3d14b1992c6981d2cfcb89c425">handle_stop_request_message</a> ()</td></tr>
<tr class="separator:a5fe22b3d14b1992c6981d2cfcb89c425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114c79dc673219d5df3b794552ca88d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a114c79dc673219d5df3b794552ca88d7">terminate_execution</a> ()</td></tr>
<tr class="separator:a114c79dc673219d5df3b794552ca88d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb5fcb3c057fc7195d4cc0826b207a9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a8eb5fcb3c057fc7195d4cc0826b207a9">listen_to_rti_TCP</a> (void *args)</td></tr>
<tr class="separator:a8eb5fcb3c057fc7195d4cc0826b207a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83fe9661682934029a42954b8fe6e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#ad83fe9661682934029a42954b8fe6e2f">synchronize_with_other_federates</a> ()</td></tr>
<tr class="separator:ad83fe9661682934029a42954b8fe6e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e74edba14fe2d25b2f05c3497c1054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#aa4e74edba14fe2d25b2f05c3497c1054">_lf_bounded_NET</a> (<a class="el" href="structtag__t.html">tag_t</a> *tag)</td></tr>
<tr class="separator:aa4e74edba14fe2d25b2f05c3497c1054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd313a38ec1a25c22cc94333146ba8fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#acd313a38ec1a25c22cc94333146ba8fc">_lf_send_next_event_tag</a> (<a class="el" href="structtag__t.html">tag_t</a> tag, <a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> wait_for_reply)</td></tr>
<tr class="separator:acd313a38ec1a25c22cc94333146ba8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b0b572736c7e851b93f08ace4b5f0a"><td class="memItemLeft" align="right" valign="top">parse_rti_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#ad3b0b572736c7e851b93f08ace4b5f0a">parse_rti_addr</a> (char *rti_addr)</td></tr>
<tr class="separator:ad3b0b572736c7e851b93f08ace4b5f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4e7460987c62f4c952552196854368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#afe4e7460987c62f4c952552196854368">set_federation_id</a> (char *fid)</td></tr>
<tr class="separator:afe4e7460987c62f4c952552196854368"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a881ede210402a3c26d9e30e2031f824e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a881ede210402a3c26d9e30e2031f824e">ERROR_SENDING_HEADER</a> = &quot;ERROR sending header information to federate via RTI&quot;</td></tr>
<tr class="separator:a881ede210402a3c26d9e30e2031f824e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb9d322e65732ec508efed2bebfec31"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a0eb9d322e65732ec508efed2bebfec31">ERROR_SENDING_MESSAGE</a> = &quot;ERROR sending message to federate via RTI&quot;</td></tr>
<tr class="separator:a0eb9d322e65732ec508efed2bebfec31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de2c61d36e14fae8de7043ff2661a34"><td class="memItemLeft" align="right" valign="top">lf_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a1de2c61d36e14fae8de7043ff2661a34">outbound_socket_mutex</a></td></tr>
<tr class="separator:a1de2c61d36e14fae8de7043ff2661a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31c3ee54cd862c9381fbf980fa7d9ef"><td class="memItemLeft" align="right" valign="top">lf_cond_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#ac31c3ee54cd862c9381fbf980fa7d9ef">port_status_changed</a></td></tr>
<tr class="separator:ac31c3ee54cd862c9381fbf980fa7d9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd2a9d602522afd72f6c524356868e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfederate__instance__t.html">federate_instance_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a8dd2a9d602522afd72f6c524356868e4">_fed</a></td></tr>
<tr class="separator:a8dd2a9d602522afd72f6c524356868e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de4491a57458e3090628acf441ae2b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfederation__metadata__t.html">federation_metadata_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8c.html#a7de4491a57458e3090628acf441ae2b5">federation_metadata</a></td></tr>
<tr class="separator:a7de4491a57458e3090628acf441ae2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Edward A. Lee (<a href="#" onclick="location.href='mai'+'lto:'+'eal'+'@b'+'erk'+'el'+'ey.'+'ed'+'u'; return false;">eal@b<span class="obfuscator">.nosp@m.</span>erke<span class="obfuscator">.nosp@m.</span>ley.e<span class="obfuscator">.nosp@m.</span>du</a>)</dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p >Copyright (c) 2020, The University of California at Berkeley.</p>
<p >Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ol>
<p >THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p >Utility functions for a federate in a federated execution. The main entry point is <a class="el" href="federate_8c.html#ad83fe9661682934029a42954b8fe6e2f">synchronize_with_other_federates()</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a89f108cab37717071993e6e76efc83d7" name="a89f108cab37717071993e6e76efc83d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f108cab37717071993e6e76efc83d7">&#9670;&nbsp;</a></span>_lf_action_for_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtrigger__t.html">trigger_t</a> * _lf_action_for_port </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Placeholder for a generated function that returns a pointer to the <a class="el" href="structtrigger__t.html">trigger_t</a> struct for the action corresponding to the specified port ID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="structtrigger__t.html">trigger_t</a> struct or null if the ID is out of range. </dd></dl>

</div>
</div>
<a id="aa4e74edba14fe2d25b2f05c3497c1054" name="aa4e74edba14fe2d25b2f05c3497c1054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e74edba14fe2d25b2f05c3497c1054">&#9670;&nbsp;</a></span>_lf_bounded_NET()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> _lf_bounded_NET </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a> *&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Modify the specified tag, if necessary, to be an earlier tag based on the current physical time. The earlier tag is necessary if this federate has downstream federates and also has physical actions that may trigger outputs. In that case, the earlier tag will be the current physical time plus the minimum delay on all such physical actions plus any other delays along the path from the triggering physical action to the output port minus one nanosecond. The modified tag is assured of being less than any output tag that might later be produced. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A pointer to the proposed NET. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this federate requires this modification and the tag was modified. </dd></dl>

</div>
</div>
<a id="a89f25989edc5bf8e0c8bf46efe9310d0" name="a89f25989edc5bf8e0c8bf46efe9310d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f25989edc5bf8e0c8bf46efe9310d0">&#9670;&nbsp;</a></span>_lf_close_inbound_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_close_inbound_socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fed_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Close the socket that receives incoming messages from the specified federate ID or RTI. This function should be called when a read of incoming socket fails or when an EOF is received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>ID of the peer federate sending messages to this federate, or -1 if the RTI. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab74e4453a091929855ab82a38074150e" name="ab74e4453a091929855ab82a38074150e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74e4453a091929855ab82a38074150e">&#9670;&nbsp;</a></span>_lf_close_outbound_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_close_outbound_socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fed_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Close the socket that sends outgoing messages to the specified federate ID. This function assumes the caller holds the outbound_socket_mutex mutex lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>ID of the peer federate receiving messages from this federate, or -1 if the RTI (centralized coordination). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60ec02f52c1a7db4c7bdbc2871eae636" name="a60ec02f52c1a7db4c7bdbc2871eae636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ec02f52c1a7db4c7bdbc2871eae636">&#9670;&nbsp;</a></span>_lf_fd_send_stop_request_to_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_fd_send_stop_request_to_rti </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Send a MSG_TYPE_STOP_REQUEST message to the RTI with payload equal to the current tag plus one microstep.</p>
<p >This function raises a global barrier on logical tag at the current tag.</p>
<p >This function assumes the caller holds the mutex lock. </p>

</div>
</div>
<a id="a77aa8325df62cb64364fb8af6b1c2334" name="a77aa8325df62cb64364fb8af6b1c2334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77aa8325df62cb64364fb8af6b1c2334">&#9670;&nbsp;</a></span>_lf_logical_tag_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_logical_tag_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag_to_send</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Send a logical tag complete (LTC) message to the RTI unless an equal or later LTC has previously been sent. This function assumes the caller holds the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag_to_send</td><td>The tag to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad48351e45d74393e322780dfeabad776" name="ad48351e45d74393e322780dfeabad776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48351e45d74393e322780dfeabad776">&#9670;&nbsp;</a></span>_lf_request_close_inbound_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_request_close_inbound_socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fed_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Request to close the socket that receives incoming messages from the specified federate ID. This sends a message to the upstream federate requesting that it close the socket. If the message is sent successfully, this returns 1. Otherwise it returns 0, which presumably means that the socket is already closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>ID of the peer federate sending messages to this federate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the MSG_TYPE_CLOSE_REQUEST message is sent successfully, 0 otherwise. </dd></dl>

</div>
</div>
<a id="acd313a38ec1a25c22cc94333146ba8fc" name="acd313a38ec1a25c22cc94333146ba8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd313a38ec1a25c22cc94333146ba8fc">&#9670;&nbsp;</a></span>_lf_send_next_event_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> _lf_send_next_event_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>&#160;</td>
          <td class="paramname"><em>wait_for_reply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If this federate depends on upstream federates or sends data to downstream federates, then send to the RTI either a NET or a TAN, depending on whether there are network outputs that depend on physical actions. If there are no such outputs, then send next event tag (NET), which will give the tag of the earliest event on the event queue, or, if the queue is empty, the timeout time, or, if there is no timeout, FOREVER.</p>
<p >A NET or TAN is a promise saying that, absent network inputs, this federate will not produce an output message with tag earlier than the NET value or (TAN,0).</p>
<p >If there are upstream federates, then after sending a NET, this will block until either the RTI grants the advance to the requested time or the wait for the response from the RTI is interrupted by a change in the event queue (e.g., a physical action triggered or a network message arrived). If there are no upstream federates, then it will not wait for a TAG (which won't be forthcoming anyway) and returns the earliest tag on the event queue.</p>
<p >If the federate has neither upstream nor downstream federates, then this returns the specified tag immediately without sending anything to the RTI.</p>
<p >If there is at least one physical action somewhere in the federate that can trigger an output to a downstream federate, then the NET is required to be less than the current physical time. If physical time is less than the earliest event in the event queue (or the event queue is empty), then this function will send a Time Advance Notice (TAN) message instead of NET. That message does not require a response from the RTI. The TAN message will be sent repeatedly as physical time advances with the time interval between messages controlled by the target parameter coordination-options: {advance-message-interval timevalue}. It will switch back to sending a NET message if and when its event queue has an event with a timestamp less than physical time.</p>
<p >If wait_for_reply is false, then this function will simply send the specified tag and return that tag immediately. This is useful when a federate is shutting down and will not be sending any more messages at all.</p>
<p >In all cases, this returns either the specified tag or another tag when it is safe to advance logical time to the returned tag. The returned tag may be less than the specified tag if there are upstream federates and either the RTI responds with a lesser tag or the wait for a response from the RTI is interrupted by a change in the event queue.</p>
<p >This function is used in centralized coordination only.</p>
<p >This function assumes the caller holds the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag. </td></tr>
    <tr><td class="paramname">wait_for_reply</td><td>If true, wait for a reply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3855de7f23c702c8d98e6cd88e6be15" name="ab3855de7f23c702c8d98e6cd88e6be15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3855de7f23c702c8d98e6cd88e6be15">&#9670;&nbsp;</a></span>_lf_send_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_send_tag </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>&#160;</td>
          <td class="paramname"><em>exit_on_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Send a tag to the RTI. This is not synchronized. It assumes the caller is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The message type (MSG_TYPE_NEXT_EVENT_TAG or MSG_TYPE_LOGICAL_TAG_COMPLETE). </td></tr>
    <tr><td class="paramname">tag</td><td>The tag. </td></tr>
    <tr><td class="paramname">exit_on_error</td><td>If set to true, exit the program if sending 'tag' fails. Print a soft error message otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd4711eb58251a2226c8b4f8be7c0d32" name="afd4711eb58251a2226c8b4f8be7c0d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4711eb58251a2226c8b4f8be7c0d32">&#9670;&nbsp;</a></span>_lf_send_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_send_time </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>&#160;</td>
          <td class="paramname"><em>exit_on_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Send a time to the RTI. This is not synchronized. It assumes the caller is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The message type (MSG_TYPE_TIMESTAMP or MSG_TYPE_TIME_ADVANCE_NOTICE). </td></tr>
    <tr><td class="paramname">time</td><td>The time. </td></tr>
    <tr><td class="paramname">exit_on_error</td><td>If set to true, exit the program if sending 'time' fails. Print a soft error message otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ca619f14cb3f3e777c8ca2e0e9ec022" name="a2ca619f14cb3f3e777c8ca2e0e9ec022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca619f14cb3f3e777c8ca2e0e9ec022">&#9670;&nbsp;</a></span>connect_to_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connect_to_federate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>remote_federate_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Connect to the federate with the specified id. This established connection will then be used in functions such as <a class="el" href="federate_8c.html#ad6916d42278d4c199272aaa884a1e01f">send_timed_message()</a> to send messages directly to the specified federate. This function first sends an MSG_TYPE_ADDRESS_QUERY message to the RTI to obtain the IP address and port number of the specified federate. It then attempts to establish a socket connection to the specified federate. If this fails, the program exits. If it succeeds, it sets element [id] of the _fed.sockets_for_outbound_p2p_connections global array to refer to the socket for communicating directly with the federate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_federate_id</td><td>The ID of the remote federate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4fb5cd6e02f70979dd3e30310d4b2bb" name="ac4fb5cd6e02f70979dd3e30310d4b2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4fb5cd6e02f70979dd3e30310d4b2bb">&#9670;&nbsp;</a></span>connect_to_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connect_to_rti </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Connect to the RTI at the specified host and port and return the socket descriptor for the connection. If this fails, the program exits. If it succeeds, it sets the _fed.socket_TCP_RTI global variable to refer to the socket for communicating with the RTI. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>A hostname, such as "localhost". </td></tr>
    <tr><td class="paramname">port_number</td><td>A port number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e2425b519aae66167fbf454f896df92" name="a0e2425b519aae66167fbf454f896df92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2425b519aae66167fbf454f896df92">&#9670;&nbsp;</a></span>create_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void create_server </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>specified_port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a server to listen to incoming physical connections from remote federates. This function only handles the creation of the server socket. The reserved port for the server socket is then sent to the RTI by sending an MSG_TYPE_ADDRESS_ADVERTISEMENT message (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html">net_common.h</a>). This function expects <a class="el" href="reactor_8h.html#a174f339edecd4463df25e673366a2b16a8fe4a05f1addc1b9a4aae17d7b166646">no</a> response from the RTI.</dd></dl>
<p>If a port is specified by the user, that will be used as the only possibility for the server. This function will fail if that port is not available. If a port is not specified, the STARTING_PORT (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html">net_common.h</a>) will be used. The function will keep incrementing the port in this case until the number of tries reaches <a class="el" href="net__common_8h.html#aff81692fc67e6f7838d9d1cff402d7f6">PORT_RANGE_LIMIT</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is similar to create_server(...) in <a class="el" href="rti_8c.html">rti.c</a>. However, it contains specific log messages for the peer to peer connections between federates. It also additionally sends an address advertisement (MSG_TYPE_ADDRESS_ADVERTISEMENT) message to the RTI informing it of the port.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">specified_port</td><td>The specified port by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa295d4779f0b5929a9bff7226f29e521" name="aa295d4779f0b5929a9bff7226f29e521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa295d4779f0b5929a9bff7226f29e521">&#9670;&nbsp;</a></span>enqueue_network_control_reactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enqueue_network_control_reactions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enqueue network control reactions. </p>

</div>
</div>
<a id="a85a8a94cd5637607e88ef32abaa2dc5b" name="a85a8a94cd5637607e88ef32abaa2dc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a8a94cd5637607e88ef32abaa2dc5b">&#9670;&nbsp;</a></span>enqueue_network_input_control_reactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enqueue_network_input_control_reactions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enqueue network input control reactions that determine if the trigger for a given network input port is going to be present at the current logical time or absent. </p>

</div>
</div>
<a id="a892e175b19f257b58dec838106b898ad" name="a892e175b19f257b58dec838106b898ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892e175b19f257b58dec838106b898ad">&#9670;&nbsp;</a></span>enqueue_network_output_control_reactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enqueue_network_output_control_reactions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enqueue network output control reactions that will send a MSG_TYPE_PORT_ABSENT message to downstream federates if a given network output port is not present. </p>

</div>
</div>
<a id="a123194949f44242acbab252bc1ffed4f" name="a123194949f44242acbab252bc1ffed4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123194949f44242acbab252bc1ffed4f">&#9670;&nbsp;</a></span>get_current_port_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor_8h.html#a759ba374f75ea0025b9af1bb35f14d7e">port_status_t</a> get_current_port_status </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the status of the port at the current tag.</p>
<p >This assumes that the caller holds the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portID</td><td>the ID of the port to determine status for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacc9f1bfb95d8b6c852a52832a9ecd9e" name="aacc9f1bfb95d8b6c852a52832a9ecd9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc9f1bfb95d8b6c852a52832a9ecd9e">&#9670;&nbsp;</a></span>get_start_time_from_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a> get_start_time_from_rti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a>&#160;</td>
          <td class="paramname"><em>my_physical_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Send the specified timestamp to the RTI and wait for a response. The specified timestamp should be current physical time of the federate, and the response will be the designated start time for the federate. This procedure blocks until the response is received from the RTI. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">my_physical_time</td><td>The physical time at this federate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The designated start time for the federate. </dd></dl>

</div>
</div>
<a id="a8a059641cbcf0e192594ea898cd09983" name="a8a059641cbcf0e192594ea898cd09983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a059641cbcf0e192594ea898cd09983">&#9670;&nbsp;</a></span>handle_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fed_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle a message being received from a remote federate.</p>
<p >This function assumes the caller does not hold the mutex lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket to read the message from </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to read </td></tr>
    <tr><td class="paramname">fed_id</td><td>The sending federate ID or -1 if the centralized coordination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2743dda029c873192d2cbad5170c252" name="ab2743dda029c873192d2cbad5170c252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2743dda029c873192d2cbad5170c252">&#9670;&nbsp;</a></span>handle_p2p_connections_from_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * handle_p2p_connections_from_federates </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ignored</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Thread to accept connections from other federates that send this federate messages directly (not through the RTI). This thread starts a thread for each accepted socket connection and, once it has opened all expected sockets, exits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignored</td><td>No argument needed for this thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a5875ee5db1e60f40b6dd8c98f3eec3" name="a3a5875ee5db1e60f40b6dd8c98f3eec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5875ee5db1e60f40b6dd8c98f3eec3">&#9670;&nbsp;</a></span>handle_port_absent_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_port_absent_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fed_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle a port absent message received from a remote federate. This just sets the last known status tag of the port specified in the message.</p>
<p >This assumes the caller does not hold the mutex, which it acquires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket to read the message from </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to read </td></tr>
    <tr><td class="paramname">fed_id</td><td>The sending federate ID or -1 if the centralized coordination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1d3825f70289972e7f2ab9fed3b24f4" name="ab1d3825f70289972e7f2ab9fed3b24f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d3825f70289972e7f2ab9fed3b24f4">&#9670;&nbsp;</a></span>handle_provisional_tag_advance_grant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_provisional_tag_advance_grant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle a provisional tag advance grant (PTAG) message from the RTI. This updates the last known TAG/PTAG and broadcasts a notification of this update, which may unblock whichever worker thread is trying to advance time. If current_time is less than the specified PTAG, then this will also insert into the event_q a dummy event with the specified tag. This will ensure that the federate advances time to the specified tag and, for centralized coordination, inserts blocking reactions and null-message-sending output reactions at that tag.</p>
<p >This function assumes the caller does not hold the mutex lock, which it acquires.</p>
<dl class="section note"><dt>Note</dt><dd>This function is similar to <a class="el" href="federate_8c.html#a7853e005f220474d4ce35be7a6560b2f">handle_tag_advance_grant()</a> except that it sets last_TAG_was_provisional to true and also it does not update the last known tag for input ports. </dd></dl>

</div>
</div>
<a id="a295baf41cee4f9450aaf7c95abede7e8" name="a295baf41cee4f9450aaf7c95abede7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295baf41cee4f9450aaf7c95abede7e8">&#9670;&nbsp;</a></span>handle_stop_granted_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_stop_granted_message </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle a MSG_TYPE_STOP_GRANTED message from the RTI.</p>
<p >This function removes the global barrier on logical time raised when <a class="el" href="reactor_8c.html#af629769c213699f0e4c9360811ee7251">request_stop()</a> was called.</p>
<p >This function assumes the caller does not hold the mutex lock, therefore, it acquires it. </p>

</div>
</div>
<a id="a5fe22b3d14b1992c6981d2cfcb89c425" name="a5fe22b3d14b1992c6981d2cfcb89c425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe22b3d14b1992c6981d2cfcb89c425">&#9670;&nbsp;</a></span>handle_stop_request_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_stop_request_message </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle a MSG_TYPE_STOP_REQUEST message from the RTI.</p>
<p >This function assumes the caller does not hold the mutex lock, therefore, it acquires it. </p>

</div>
</div>
<a id="a7853e005f220474d4ce35be7a6560b2f" name="a7853e005f220474d4ce35be7a6560b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7853e005f220474d4ce35be7a6560b2f">&#9670;&nbsp;</a></span>handle_tag_advance_grant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_tag_advance_grant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle a time advance grant (TAG) message from the RTI. This updates the last known status tag for each network input port, and broadcasts a signal, which may cause a blocking control reaction to unblock.</p>
<p >In addition, this updates the last known TAG/PTAG and broadcasts a notification of this update, which may unblock whichever worker thread is trying to advance time.</p>
<p >This function assumes the caller does not hold the mutex lock, which it acquires.</p>
<dl class="section note"><dt>Note</dt><dd>This function is very similar to handle_provisinal_tag_advance_grant() except that it sets last_TAG_was_provisional to false. </dd></dl>

</div>
</div>
<a id="afe62a8b474897e95ba73528ffa23b621" name="afe62a8b474897e95ba73528ffa23b621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe62a8b474897e95ba73528ffa23b621">&#9670;&nbsp;</a></span>handle_tagged_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_tagged_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fed_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handle a timed message being received from a remote federate via the RTI or directly from other federates. This will read the tag encoded in the header and calculate an offset to pass to the schedule function. This function assumes the caller does not hold the mutex lock. Instead of holding the mutex lock, this function calls _lf_increment_global_tag_barrier with the tag carried in the message header as an argument. This ensures that the current tag will not advance to the tag of the message if it is in the future, or the tag will not advance at all if the tag of the message is now or in the past. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket to read the message from. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to read. </td></tr>
    <tr><td class="paramname">fed_id</td><td>The sending federate ID or -1 if the centralized coordination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a943c3d7aa45a6af5b6d1567cd4ce841c" name="a943c3d7aa45a6af5b6d1567cd4ce841c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943c3d7aa45a6af5b6d1567cd4ce841c">&#9670;&nbsp;</a></span>is_input_control_reaction_blocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> is_input_control_reaction_blocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return true if there is an input control reaction blocked waiting for input. This assumes the caller holds the mutex. </p>

</div>
</div>
<a id="ab48114c777d79a6c8ba5611414dc2581" name="ab48114c777d79a6c8ba5611414dc2581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48114c777d79a6c8ba5611414dc2581">&#9670;&nbsp;</a></span>listen_for_upstream_messages_from_downstream_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * listen_for_upstream_messages_from_downstream_federates </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fed_id_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >For each incoming message socket, we create this thread that listens for upstream messages. Currently, the only possible upstream message is MSG_TYPE_CLOSE_REQUEST. If this thread receives that message, then closes the socket. The idea here is that a peer-to-peer socket connection is always closed from the sending end, never from the receiving end. This way, any sends in progress complete before the socket is actually closed. </p>

</div>
</div>
<a id="a0ed912257c1b82c7727c549aec8f3a73" name="a0ed912257c1b82c7727c549aec8f3a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed912257c1b82c7727c549aec8f3a73">&#9670;&nbsp;</a></span>listen_to_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * listen_to_federates </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fed_id_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Thread that listens for inputs from other federates. This thread listens for messages of type MSG_TYPE_P2P_TAGGED_MESSAGE from the specified peer federate and calls schedule to schedule an event. If an error occurs or an EOF is received from the peer, then this procedure returns, terminating the thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed_id_ptr</td><td>A pointer to a uint16_t containing federate ID being listened to. This procedure frees the memory pointed to before returning.</td></tr>
  </table>
  </dd>
</dl>
<p>Thread that listens for inputs from other federates. This thread listens for messages of type MSG_TYPE_P2P_MESSAGE, MSG_TYPE_P2P_TAGGED_MESSAGE, or MSG_TYPE_PORT_ABSENT (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html">net_common.h</a>) from the specified peer federate and calls the appropriate handling function for each message type. If an <a class="el" href="core_2utils_2util_8h.html#a4866b2d37ffc80c5ba705d3fcd1e0ecf">error</a> occurs or an EOF is received from the peer, then this procedure sets the corresponding socket in _fed.sockets_for_inbound_p2p_connections to -1 and returns, terminating the thread. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed_id_ptr</td><td>A pointer to a uint16_t containing federate ID being listened to. This procedure frees the memory pointed to before returning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eb5fcb3c057fc7195d4cc0826b207a9" name="a8eb5fcb3c057fc7195d4cc0826b207a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb5fcb3c057fc7195d4cc0826b207a9">&#9670;&nbsp;</a></span>listen_to_rti_TCP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * listen_to_rti_TCP </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Thread that listens for TCP inputs from the RTI. When a physical message arrives, this calls schedule. </p>

</div>
</div>
<a id="a07d570a16cab26d91c4b47fa5dd6ef6a" name="a07d570a16cab26d91c4b47fa5dd6ef6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d570a16cab26d91c4b47fa5dd6ef6a">&#9670;&nbsp;</a></span>mark_all_unknown_ports_as_absent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mark_all_unknown_ports_as_absent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Mark all status fields of unknown network input ports as absent. </p>

</div>
</div>
<a id="ad92ed203ebed8e9d8a3727d9b2583c56" name="ad92ed203ebed8e9d8a3727d9b2583c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92ed203ebed8e9d8a3727d9b2583c56">&#9670;&nbsp;</a></span>mark_control_reaction_waiting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mark_control_reaction_waiting </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>&#160;</td>
          <td class="paramname"><em>waiting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Mark the trigger associated with the specified port to indicate whether a control reaction is waiting. </p>

</div>
</div>
<a id="ad3b0b572736c7e851b93f08ace4b5f0a" name="ad3b0b572736c7e851b93f08ace4b5f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b0b572736c7e851b93f08ace4b5f0a">&#9670;&nbsp;</a></span>parse_rti_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parse_rti_code_t parse_rti_addr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>rti_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Parse the address of the RTI and store them into the global federation_metadata struct. </p><dl class="section return"><dt>Returns</dt><dd>a parse_rti_code_t indicating the result of the parse. </dd></dl>

</div>
</div>
<a id="af89b0ab26ec13c6deafeb05c3c14a88e" name="af89b0ab26ec13c6deafeb05c3c14a88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89b0ab26ec13c6deafeb05c3c14a88e">&#9670;&nbsp;</a></span>reset_status_fields_on_input_port_triggers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset_status_fields_on_input_port_triggers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reset the status fields on network input ports to unknown.</p>
<dl class="section note"><dt>Note</dt><dd>This function must be called at the beginning of each logical time. </dd></dl>

</div>
</div>
<a id="a7e7ce364ced211e3892f71c47cff125c" name="a7e7ce364ced211e3892f71c47cff125c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7ce364ced211e3892f71c47cff125c">&#9670;&nbsp;</a></span>schedule_message_received_from_network_already_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor_8h.html#a3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> schedule_message_received_from_network_already_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Version of <a class="el" href="schedule_8c.html#a0ecdb5df31eef1cff7d639badc3e7ee8">schedule_value()</a> similar to that in <a class="el" href="reactor__common_8c.html">reactor_common.c</a> except that it does not acquire the mutex lock and has a special behavior during startup where it can inject reactions to the reaction queue if execution has not started yet. It is also responsible for setting the intended tag of the network message based on the calculated delay. This function assumes that the caller holds the mutex lock.</p>
<p >This is used for handling incoming timed messages to a federate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The action or timer to be triggered. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag of the message received over the network. </td></tr>
    <tr><td class="paramname">value</td><td>Dynamically allocated memory containing the value to send. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array, if it is an array, or 1 for a scalar and 0 for no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error. </dd></dl>

</div>
</div>
<a id="a76f0bc068b7a7c4a30983172eea59767" name="a76f0bc068b7a7c4a30983172eea59767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f0bc068b7a7c4a30983172eea59767">&#9670;&nbsp;</a></span>send_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int send_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>message_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>federate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>next_destination_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Send a message to another federate directly or via the RTI. This method assumes that the caller does not hold the outbound_socket_mutex lock, which it acquires to perform the send.</p>
<p >If the socket connection to the remote federate or the RTI has been broken, then this returns 0 without sending. Otherwise, it returns 1.</p>
<dl class="section note"><dt>Note</dt><dd>This function is similar to <a class="el" href="federate_8c.html#ad6916d42278d4c199272aaa884a1e01f">send_timed_message()</a> except that it does not deal with time and timed_messages.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_type</td><td>The type of the message being sent. Currently can be MSG_TYPE_TAGGED_MESSAGE for messages sent via RTI or MSG_TYPE_P2P_TAGGED_MESSAGE for messages sent between federates. </td></tr>
    <tr><td class="paramname">port</td><td>The ID of the destination port. </td></tr>
    <tr><td class="paramname">federate</td><td>The ID of the destination federate. </td></tr>
    <tr><td class="paramname">next_destination_str</td><td>The name of the next destination in string format </td></tr>
    <tr><td class="paramname">length</td><td>The message length. </td></tr>
    <tr><td class="paramname">message</td><td>The message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the message has been sent, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a99d69c653591a4991b35ffd314ac7aad" name="a99d69c653591a4991b35ffd314ac7aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d69c653591a4991b35ffd314ac7aad">&#9670;&nbsp;</a></span>send_neighbor_structure_to_RTI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_neighbor_structure_to_RTI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rti_socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generated function that sends information about connections between this federate and other federates where messages are routed through the RTI. Currently, this only includes logical connections when the coordination is centralized. This information is needed for the RTI to perform the centralized coordination. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html#a48ec489cb1543b161c262f4bee6c9598">MSG_TYPE_NEIGHBOR_STRUCTURE</a> in <a class="el" href="net__common_8h.html">net_common.h</a> </dd></dl>

</div>
</div>
<a id="a4a188ed34f9cf3a6d2ede7a033089bdd" name="a4a188ed34f9cf3a6d2ede7a033089bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a188ed34f9cf3a6d2ede7a033089bdd">&#9670;&nbsp;</a></span>send_port_absent_to_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_port_absent_to_federate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>additional_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>fed_ID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Send a port absent message to federate with fed_ID, informing the remote federate that the current federate will not produce an event on this network port at the current logical time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">additional_delay</td><td>The offset applied to the timestamp using after. The additional delay will be greater or equal to zero if an after is used on the connection. If no after is given in the program, -1 is passed. </td></tr>
    <tr><td class="paramname">port_ID</td><td>The ID of the receiving port. </td></tr>
    <tr><td class="paramname">fed_ID</td><td>The fed ID of the receiving federate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6916d42278d4c199272aaa884a1e01f" name="ad6916d42278d4c199272aaa884a1e01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6916d42278d4c199272aaa884a1e01f">&#9670;&nbsp;</a></span>send_timed_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int send_timed_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>additional_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>message_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>federate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>next_destination_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Send the specified timestamped message to the specified port in the specified federate via the RTI or directly to a federate depending on the given socket. The timestamp is calculated as current_logical_time + additional delay which is greater than or equal to zero. The port should be an input port of a reactor in the destination federate. This version does include the timestamp in the message. The caller can reuse or free the memory after this returns.</p>
<p >If the socket connection to the remote federate or the RTI has been broken, then this returns 0 without sending. Otherwise, it returns 1.</p>
<p >This method assumes that the caller does not hold the outbound_socket_mutex lock, which it acquires to perform the send.</p>
<dl class="section note"><dt>Note</dt><dd>This function is similar to <a class="el" href="federate_8c.html#a76f0bc068b7a7c4a30983172eea59767">send_message()</a> except that it sends timed messages and also contains logics related to time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">additional_delay</td><td>The offset applied to the timestamp using after. The additional delay will be greater or equal to zero if an after is used on the connection. If no after is given in the program, -1 is passed. </td></tr>
    <tr><td class="paramname">message_type</td><td>The type of the message being sent. Currently can be MSG_TYPE_TAGGED_MESSAGE for messages sent via RTI or MSG_TYPE_P2P_TAGGED_MESSAGE for messages sent between federates. </td></tr>
    <tr><td class="paramname">port</td><td>The ID of the destination port. </td></tr>
    <tr><td class="paramname">federate</td><td>The ID of the destination federate. </td></tr>
    <tr><td class="paramname">next_destination_str</td><td>The next destination in string format (RTI or federate) (used for reporting errors). </td></tr>
    <tr><td class="paramname">length</td><td>The message length. </td></tr>
    <tr><td class="paramname">message</td><td>The message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the message has been sent, 0 otherwise. </dd></dl>

</div>
</div>
<a id="afe4e7460987c62f4c952552196854368" name="afe4e7460987c62f4c952552196854368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4e7460987c62f4c952552196854368">&#9670;&nbsp;</a></span>set_federation_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_federation_id </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the federation_id of this federate to fid. </p>

</div>
</div>
<a id="a26a55f84538e1d96832c6247d74e7da6" name="a26a55f84538e1d96832c6247d74e7da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a55f84538e1d96832c6247d74e7da6">&#9670;&nbsp;</a></span>set_network_port_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_network_port_status </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="reactor_8h.html#a759ba374f75ea0025b9af1bb35f14d7e">port_status_t</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the status of network port with id portID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portID</td><td>The network port ID </td></tr>
    <tr><td class="paramname">status</td><td>The network port status (port_status_t) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad83fe9661682934029a42954b8fe6e2f" name="ad83fe9661682934029a42954b8fe6e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83fe9661682934029a42954b8fe6e2f">&#9670;&nbsp;</a></span>synchronize_with_other_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void synchronize_with_other_federates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Synchronize the start with other federates via the RTI. This assumes that a connection to the RTI is already made and _fed.socket_TCP_RTI is valid. It then sends the current logical time to the RTI and waits for the RTI to respond with a specified time. It starts a thread to listen for messages from the RTI. It then waits for physical time to match the specified time, sets current logical time to the time returned by the RTI, and then returns. If &ndash;fast was specified, then this does not wait for physical time to match the logical start time returned by the RTI.</p>
<p >FIXME: Possibly should be renamed </p>

</div>
</div>
<a id="a114c79dc673219d5df3b794552ca88d7" name="a114c79dc673219d5df3b794552ca88d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114c79dc673219d5df3b794552ca88d7">&#9670;&nbsp;</a></span>terminate_execution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void terminate_execution </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Close sockets used to communicate with other federates, if they are open, and send a MSG_TYPE_RESIGN message to the RTI. This implements the function defined in <a class="el" href="reactor_8h.html">reactor.h</a>. For unfederated execution, the code generator generates an empty implementation. </p>

</div>
</div>
<a id="aa9f7065af94169d68152aa9db4a15cc5" name="aa9f7065af94169d68152aa9db4a15cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f7065af94169d68152aa9db4a15cc5">&#9670;&nbsp;</a></span>update_last_known_status_on_input_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_last_known_status_on_input_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Update the last known status tag of a network input port to the value of "tag". This is the largest tag at which the status (present or absent) of the port was known.</p>
<p >This function assumes the caller holds the mutex, and, if the tag actually increases, it notifies the waiting control reaction if there is one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag on which the latest status of network input ports is known. </td></tr>
    <tr><td class="paramname">portID</td><td>The port ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0858ebda70e9bc60f76b9d2aa3df39ef" name="a0858ebda70e9bc60f76b9d2aa3df39ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0858ebda70e9bc60f76b9d2aa3df39ef">&#9670;&nbsp;</a></span>update_last_known_status_on_input_ports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_last_known_status_on_input_ports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Update the last known status tag of all network input ports to the value of <code>tag</code>, unless that the provided <code>tag</code> is less than the last_known_status_tag of the port. This is called when all inputs to network ports with tags up to an including <code>tag</code> have been received by those ports. If any update occurs and if there are control reactions blocked, then this broadcasts a signal to potentially unblock those control reactions.</p>
<p >This assumes the caller holds the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag on which the latest status of network input ports is known. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4e0b0634806dadc6bda729c63dc700f" name="af4e0b0634806dadc6bda729c63dc700f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e0b0634806dadc6bda729c63dc700f">&#9670;&nbsp;</a></span>wait_until_port_status_known()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait_until_port_status_known </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>STP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Wait until the status of network port "port_ID" is known.</p>
<p >In decentralized coordination mode, the wait time is capped by "STP", after which the status of the port is presumed to be absent.</p>
<p >This function assumes the holder does not hold a mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_ID</td><td>The ID of the network port </td></tr>
    <tr><td class="paramname">STP</td><td>The STP offset of the port </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8dd2a9d602522afd72f6c524356868e4" name="a8dd2a9d602522afd72f6c524356868e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd2a9d602522afd72f6c524356868e4">&#9670;&nbsp;</a></span>_fed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfederate__instance__t.html">federate_instance_t</a> _fed</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        .socket_TCP_RTI = -1,</div>
<div class="line">        .number_of_inbound_p2p_connections = 0,</div>
<div class="line">        .inbound_socket_listeners = NULL,</div>
<div class="line">        .number_of_outbound_p2p_connections = 0,</div>
<div class="line">        .sockets_for_inbound_p2p_connections = { -1 },</div>
<div class="line">        .sockets_for_outbound_p2p_connections = { -1 },</div>
<div class="line">        .inbound_p2p_handling_thread_id = 0,</div>
<div class="line">        .server_socket = -1,</div>
<div class="line">        .server_port = -1,</div>
<div class="line">        .last_TAG = {.time = <a class="code hl_define" href="tag_8h.html#a9e5c19968af97bd64f46650ec8732318">NEVER</a>, .microstep = 0u},</div>
<div class="line">        .is_last_TAG_provisional = <span class="keyword">false</span>,</div>
<div class="line">        .waiting_for_TAG = <span class="keyword">false</span>,</div>
<div class="line">        .has_upstream = <span class="keyword">false</span>,</div>
<div class="line">        .has_downstream = <span class="keyword">false</span>,</div>
<div class="line">        .sent_a_stop_request_to_rti = <span class="keyword">false</span>,</div>
<div class="line">        .last_sent_LTC = (<a class="code hl_struct" href="structtag__t.html">tag_t</a>) {.time = <a class="code hl_define" href="tag_8h.html#a9e5c19968af97bd64f46650ec8732318">NEVER</a>, .microstep = 0u},</div>
<div class="line">        .last_sent_NET = (<a class="code hl_struct" href="structtag__t.html">tag_t</a>) {.time = <a class="code hl_define" href="tag_8h.html#a9e5c19968af97bd64f46650ec8732318">NEVER</a>, .microstep = 0u},</div>
<div class="line">        .min_delay_from_physical_action_to_federate_output = <a class="code hl_define" href="tag_8h.html#a9e5c19968af97bd64f46650ec8732318">NEVER</a>,</div>
<div class="line">        .triggers_for_network_input_control_reactions = NULL,</div>
<div class="line">        .triggers_for_network_input_control_reactions_size = 0,</div>
<div class="line">        .trigger_for_network_output_control_reactions = NULL</div>
<div class="line">}</div>
<div class="ttc" id="astructtag__t_html"><div class="ttname"><a href="structtag__t.html">tag_t</a></div><div class="ttdef"><b>Definition:</b> tag.h:103</div></div>
<div class="ttc" id="atag_8h_html_a9e5c19968af97bd64f46650ec8732318"><div class="ttname"><a href="tag_8h.html#a9e5c19968af97bd64f46650ec8732318">NEVER</a></div><div class="ttdeci">#define NEVER</div><div class="ttdef"><b>Definition:</b> tag.h:61</div></div>
</div><!-- fragment --><p >The state of this federate instance. </p>

</div>
</div>
<a id="a881ede210402a3c26d9e30e2031f824e" name="a881ede210402a3c26d9e30e2031f824e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881ede210402a3c26d9e30e2031f824e">&#9670;&nbsp;</a></span>ERROR_SENDING_HEADER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ERROR_SENDING_HEADER = &quot;ERROR sending header information to federate via RTI&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0eb9d322e65732ec508efed2bebfec31" name="a0eb9d322e65732ec508efed2bebfec31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb9d322e65732ec508efed2bebfec31">&#9670;&nbsp;</a></span>ERROR_SENDING_MESSAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ERROR_SENDING_MESSAGE = &quot;ERROR sending message to federate via RTI&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7de4491a57458e3090628acf441ae2b5" name="a7de4491a57458e3090628acf441ae2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de4491a57458e3090628acf441ae2b5">&#9670;&nbsp;</a></span>federation_metadata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfederation__metadata__t.html">federation_metadata_t</a> federation_metadata</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    .federation_id =  <span class="stringliteral">&quot;Unidentified Federation&quot;</span>,</div>
<div class="line">    .rti_host = NULL,</div>
<div class="line">    .rti_port = -1,</div>
<div class="line">    .rti_user = NULL</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1de2c61d36e14fae8de7043ff2661a34" name="a1de2c61d36e14fae8de7043ff2661a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de2c61d36e14fae8de7043ff2661a34">&#9670;&nbsp;</a></span>outbound_socket_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lf_mutex_t outbound_socket_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac31c3ee54cd862c9381fbf980fa7d9ef" name="ac31c3ee54cd862c9381fbf980fa7d9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31c3ee54cd862c9381fbf980fa7d9ef">&#9670;&nbsp;</a></span>port_status_changed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lf_cond_t port_status_changed</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
