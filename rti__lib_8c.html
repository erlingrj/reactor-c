<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: core/federated/RTI/rti_lib.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">reactor-c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li><li class="navelem"><a class="el" href="dir_da79f73d8cf16fc09c9e3a52dcc440a7.html">federated</a></li><li class="navelem"><a class="el" href="dir_b52e7938672f1d30fc92120ae2e8e089.html">RTI</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">rti_lib.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="rti__lib_8h_source.html">rti_lib.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acde4076cd96817debe76e74fca261c70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#acde4076cd96817debe76e74fca261c70">create_server</a> (int32_t specified_port, uint16_t port, <a class="el" href="rti__lib_8h.html#a54c375e3893ff5969d20df65b90c8335">socket_type_t</a> socket_type)</td></tr>
<tr class="separator:acde4076cd96817debe76e74fca261c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c94ce50b24ed5cc0bfce3d548d8e59f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a2c94ce50b24ed5cc0bfce3d548d8e59f">send_tag_advance_grant</a> (<a class="el" href="structfederate__t.html">federate_t</a> *fed, <a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="separator:a2c94ce50b24ed5cc0bfce3d548d8e59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa067d8ff2e12b42f8c1f011758231be1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#aa067d8ff2e12b42f8c1f011758231be1">transitive_next_event</a> (<a class="el" href="structfederate__t.html">federate_t</a> *fed, <a class="el" href="structtag__t.html">tag_t</a> candidate, bool visited[])</td></tr>
<tr class="separator:aa067d8ff2e12b42f8c1f011758231be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36a04086b8af885621e5f808efecd23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#ab36a04086b8af885621e5f808efecd23">send_provisional_tag_advance_grant</a> (<a class="el" href="structfederate__t.html">federate_t</a> *fed, <a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="separator:ab36a04086b8af885621e5f808efecd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e4672b8d5c3b0e42bbb0c17d01cccd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a70e4672b8d5c3b0e42bbb0c17d01cccd">send_advance_grant_if_safe</a> (<a class="el" href="structfederate__t.html">federate_t</a> *fed)</td></tr>
<tr class="separator:a70e4672b8d5c3b0e42bbb0c17d01cccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05299fb2838277ff1f030448c9cf1ad8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a05299fb2838277ff1f030448c9cf1ad8">send_downstream_advance_grants_if_safe</a> (<a class="el" href="structfederate__t.html">federate_t</a> *fed, bool visited[])</td></tr>
<tr class="separator:a05299fb2838277ff1f030448c9cf1ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7190c8d1000afb0a5e8898011d041917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a7190c8d1000afb0a5e8898011d041917">update_federate_next_event_tag_locked</a> (uint16_t federate_id, <a class="el" href="structtag__t.html">tag_t</a> next_event_tag)</td></tr>
<tr class="memdesc:a7190c8d1000afb0a5e8898011d041917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the next event tag of federate <code>federate_id</code>.  <br /></td></tr>
<tr class="separator:a7190c8d1000afb0a5e8898011d041917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6696c6969eb341c48269c2da6cec0caf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a6696c6969eb341c48269c2da6cec0caf">handle_port_absent_message</a> (<a class="el" href="structfederate__t.html">federate_t</a> *sending_federate, unsigned char *buffer)</td></tr>
<tr class="separator:a6696c6969eb341c48269c2da6cec0caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6a599f3f5b9cf66a147b0f9ca657c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#afc6a599f3f5b9cf66a147b0f9ca657c8">handle_timed_message</a> (<a class="el" href="structfederate__t.html">federate_t</a> *sending_federate, unsigned char *buffer)</td></tr>
<tr class="separator:afc6a599f3f5b9cf66a147b0f9ca657c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bba97c8acc2b80259f8b94b01e1697d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a6bba97c8acc2b80259f8b94b01e1697d">handle_logical_tag_complete</a> (<a class="el" href="structfederate__t.html">federate_t</a> *fed)</td></tr>
<tr class="separator:a6bba97c8acc2b80259f8b94b01e1697d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dee2c405d4fe62278a1cf972272bd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a77dee2c405d4fe62278a1cf972272bd2">handle_next_event_tag</a> (<a class="el" href="structfederate__t.html">federate_t</a> *fed)</td></tr>
<tr class="separator:a77dee2c405d4fe62278a1cf972272bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d99ea51641cde8d7d65c06e43581f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a4d99ea51641cde8d7d65c06e43581f19">_lf_rti_broadcast_stop_time_to_federates_already_locked</a> ()</td></tr>
<tr class="separator:a4d99ea51641cde8d7d65c06e43581f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ac8c4d61e522fc3587a7469bdc7afb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a97ac8c4d61e522fc3587a7469bdc7afb">mark_federate_requesting_stop</a> (<a class="el" href="structfederate__t.html">federate_t</a> *fed)</td></tr>
<tr class="separator:a97ac8c4d61e522fc3587a7469bdc7afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bea17520db7f471b8a04d20c7db5f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a76bea17520db7f471b8a04d20c7db5f5">handle_stop_request_message</a> (<a class="el" href="structfederate__t.html">federate_t</a> *fed)</td></tr>
<tr class="separator:a76bea17520db7f471b8a04d20c7db5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21c2b5333b021d6308a807c1f9e8844"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#aa21c2b5333b021d6308a807c1f9e8844">handle_stop_request_reply</a> (<a class="el" href="structfederate__t.html">federate_t</a> *fed)</td></tr>
<tr class="separator:aa21c2b5333b021d6308a807c1f9e8844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0424648d3659346e9c7c645cca35d470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a0424648d3659346e9c7c645cca35d470">handle_address_query</a> (uint16_t fed_id)</td></tr>
<tr class="separator:a0424648d3659346e9c7c645cca35d470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4f3aae4aa73c87569b677f2c0957b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a3f4f3aae4aa73c87569b677f2c0957b7">handle_address_ad</a> (uint16_t federate_id)</td></tr>
<tr class="separator:a3f4f3aae4aa73c87569b677f2c0957b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf552da2c0c98857a8f772fe19c4e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a9cf552da2c0c98857a8f772fe19c4e9d">handle_timestamp</a> (<a class="el" href="structfederate__t.html">federate_t</a> *my_fed)</td></tr>
<tr class="separator:a9cf552da2c0c98857a8f772fe19c4e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a91427e9fa6a65bc44d5ec599688337"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a6a91427e9fa6a65bc44d5ec599688337">send_physical_clock</a> (unsigned char message_type, <a class="el" href="structfederate__t.html">federate_t</a> *fed, <a class="el" href="rti__lib_8h.html#a54c375e3893ff5969d20df65b90c8335">socket_type_t</a> socket_type)</td></tr>
<tr class="separator:a6a91427e9fa6a65bc44d5ec599688337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c5af408abe8a53506b2fb406046e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#ac5c5af408abe8a53506b2fb406046e14">handle_physical_clock_sync_message</a> (<a class="el" href="structfederate__t.html">federate_t</a> *my_fed, <a class="el" href="rti__lib_8h.html#a54c375e3893ff5969d20df65b90c8335">socket_type_t</a> socket_type)</td></tr>
<tr class="separator:ac5c5af408abe8a53506b2fb406046e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272b481a0cc2f86f21c75e8efa19a551"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a272b481a0cc2f86f21c75e8efa19a551">clock_synchronization_thread</a> (void *noargs)</td></tr>
<tr class="separator:a272b481a0cc2f86f21c75e8efa19a551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a50a2d7ea45420d332bc7444ce34518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a7a50a2d7ea45420d332bc7444ce34518">handle_federate_resign</a> (<a class="el" href="structfederate__t.html">federate_t</a> *my_fed)</td></tr>
<tr class="separator:a7a50a2d7ea45420d332bc7444ce34518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab8c2212ee68f6a92b6358a3081cd82"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a1ab8c2212ee68f6a92b6358a3081cd82">federate_thread_TCP</a> (void *fed)</td></tr>
<tr class="separator:a1ab8c2212ee68f6a92b6358a3081cd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408613f224083aeba6da2c47f86006b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a408613f224083aeba6da2c47f86006b7">send_reject</a> (int socket_id, unsigned char error_code)</td></tr>
<tr class="separator:a408613f224083aeba6da2c47f86006b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4f9257c2e2e4b122562b175ae0bb77"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#abf4f9257c2e2e4b122562b175ae0bb77">receive_and_check_fed_id_message</a> (int socket_id, struct sockaddr_in *client_fd)</td></tr>
<tr class="separator:abf4f9257c2e2e4b122562b175ae0bb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001e31b4af3721b103195014d779b909"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a001e31b4af3721b103195014d779b909">receive_connection_information</a> (int socket_id, uint16_t fed_id)</td></tr>
<tr class="separator:a001e31b4af3721b103195014d779b909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b7dee1852120f00c4f7415a84550d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a31b7dee1852120f00c4f7415a84550d3">receive_udp_message_and_set_up_clock_sync</a> (int socket_id, uint16_t fed_id)</td></tr>
<tr class="separator:a31b7dee1852120f00c4f7415a84550d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8907ccab075522f7b84de579d50030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#acf8907ccab075522f7b84de579d50030">connect_to_federates</a> (int socket_descriptor)</td></tr>
<tr class="separator:acf8907ccab075522f7b84de579d50030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6af5f2343ecf9ed87cdbebd98b94271"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#ac6af5f2343ecf9ed87cdbebd98b94271">respond_to_erroneous_connections</a> (void *<a class="el" href="hashmap_8h.html#abddc82f328c9384f6c66210d6740e6aa">nothing</a>)</td></tr>
<tr class="separator:ac6af5f2343ecf9ed87cdbebd98b94271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9569e1329c5a061249aae331a8e77403"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a9569e1329c5a061249aae331a8e77403">initialize_federate</a> (uint16_t id)</td></tr>
<tr class="separator:a9569e1329c5a061249aae331a8e77403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc1fe69c154d09d88de1f1c06eb4b0d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a6cc1fe69c154d09d88de1f1c06eb4b0d">start_rti_server</a> (uint16_t port)</td></tr>
<tr class="separator:a6cc1fe69c154d09d88de1f1c06eb4b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005cb43e8e6c7795c8f0db27e2424475"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a005cb43e8e6c7795c8f0db27e2424475">wait_for_federates</a> (int socket_descriptor)</td></tr>
<tr class="separator:a005cb43e8e6c7795c8f0db27e2424475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5079a0bdbc96962460a991aa880725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#aeb5079a0bdbc96962460a991aa880725">usage</a> (int argc, char *argv[])</td></tr>
<tr class="separator:aeb5079a0bdbc96962460a991aa880725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d07d769654a6bfec790c24e1c65cd77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a6d07d769654a6bfec790c24e1c65cd77">process_clock_sync_args</a> (int argc, char *argv[])</td></tr>
<tr class="separator:a6d07d769654a6bfec790c24e1c65cd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de011aeee37cd0347b5e01d7e3baed4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a8de011aeee37cd0347b5e01d7e3baed4">process_args</a> (int argc, char *argv[])</td></tr>
<tr class="separator:a8de011aeee37cd0347b5e01d7e3baed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a104f9a0ac7ff4aa717e0462b8ac445ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_r_t_i__instance__t.html">RTI_instance_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a104f9a0ac7ff4aa717e0462b8ac445ea">_RTI</a></td></tr>
<tr class="separator:a104f9a0ac7ff4aa717e0462b8ac445ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94849214863f76b3f7c59a78bd2ad624"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__lib_8c.html#a94849214863f76b3f7c59a78bd2ad624">_lf_rti_stop_granted_already_sent_to_federates</a> = false</td></tr>
<tr class="separator:a94849214863f76b3f7c59a78bd2ad624"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Edward A. Lee (<a href="#" onclick="location.href='mai'+'lto:'+'eal'+'@b'+'erk'+'el'+'ey.'+'ed'+'u'; return false;">eal@b<span class="obfuscator">.nosp@m.</span>erke<span class="obfuscator">.nosp@m.</span>ley.e<span class="obfuscator">.nosp@m.</span>du</a>) </dd>
<dd>
Soroush Bateni</dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>Copyright (c) 2020, The University of California at Berkeley.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Runtime infrastructure for distributed Lingua Franca programs.</p>
<p>This implementation creates one thread per federate so as to be able to take advantage of multiple cores. It may be more efficient, however, to use select() instead to read from the multiple socket connections to each federate.</p>
<p>This implementation sends messages in little endian order because Intel, RISC V, and Arm processors are little endian. This is not what is normally considered "network order", but we control both ends, and hence, for commonly used processors, this will be more efficient since it won't have to swap bytes.</p>
<p>This implementation of the RTI should be considered a reference implementation. In the future it might be re-implemented in Java or Kotlin. Or we could bootstrap and implement it using Lingua Franca. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4d99ea51641cde8d7d65c06e43581f19" name="a4d99ea51641cde8d7d65c06e43581f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d99ea51641cde8d7d65c06e43581f19">&#9670;&#160;</a></span>_lf_rti_broadcast_stop_time_to_federates_already_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_rti_broadcast_stop_time_to_federates_already_locked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Once the RTI has seen proposed tags from all connected federates, it will broadcast a MSG_TYPE_STOP_GRANTED carrying the _RTI.max_stop_tag. This function also checks the most recently received NET from each federate and resets that be no greater than the _RTI.max_stop_tag.</p>
<p>This function assumes the caller holds the _RTI.rti_mutex lock. </p>

</div>
</div>
<a id="a272b481a0cc2f86f21c75e8efa19a551" name="a272b481a0cc2f86f21c75e8efa19a551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272b481a0cc2f86f21c75e8efa19a551">&#9670;&#160;</a></span>clock_synchronization_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * clock_synchronization_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>noargs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A (quasi-)periodic thread that performs clock synchronization with each federate. It starts by waiting a time given by _RTI.clock_sync_period_ns and then iterates over the federates, performing a complete clock synchronization interaction with each federate before proceeding to the next federate. The interaction starts with this RTI sending a snapshot of its physical clock to the federate (message T1). It then waits for a reply and then sends another snapshot of its physical clock (message T4). It then follows that T4 message with a coded probe message that the federate can use to discard the session if the network is congested. </p>

</div>
</div>
<a id="acf8907ccab075522f7b84de579d50030" name="acf8907ccab075522f7b84de579d50030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8907ccab075522f7b84de579d50030">&#9670;&#160;</a></span>connect_to_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connect_to_federates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_descriptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Authenticate incoming federate by performing HMAC-based authentication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket for the incoming federate tryting to authenticate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if authentication is successful and false otherwise. Wait for one incoming connection request from each federate, and upon receiving it, create a thread to communicate with that federate. Return when all federates have connected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_descriptor</td><td>The socket on which to accept connections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acde4076cd96817debe76e74fca261c70" name="acde4076cd96817debe76e74fca261c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde4076cd96817debe76e74fca261c70">&#9670;&#160;</a></span>create_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int create_server </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>specified_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rti__lib_8h.html#a54c375e3893ff5969d20df65b90c8335">socket_type_t</a>&#160;</td>
          <td class="paramname"><em>socket_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a server and enable listening for socket connections.</p>
<dl class="section note"><dt>Note</dt><dd>This function is similar to create_server(...) in <a class="el" href="federate_8c.html">federate.c</a>. However, it contains logs that are specific to the RTI.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port number to use. </td></tr>
    <tr><td class="paramname">socket_type</td><td>The type of the socket for the server (TCP or UDP). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The socket descriptor on which to accept connections. </dd></dl>

</div>
</div>
<a id="a1ab8c2212ee68f6a92b6358a3081cd82" name="a1ab8c2212ee68f6a92b6358a3081cd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab8c2212ee68f6a92b6358a3081cd82">&#9670;&#160;</a></span>federate_thread_TCP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * federate_thread_TCP </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread handling TCP communication with a federate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>A pointer to the federate's struct that has the socket descriptor for the federate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f4f3aae4aa73c87569b677f2c0957b7" name="a3f4f3aae4aa73c87569b677f2c0957b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4f3aae4aa73c87569b677f2c0957b7">&#9670;&#160;</a></span>handle_address_ad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_address_ad </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>federate_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle address advertisement messages (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html#ae004cb4e5add42afe5483f6706e11d35">MSG_TYPE_ADDRESS_ADVERTISEMENT</a> in <a class="el" href="net__common_8h.html">net_common.h</a>). The federate is expected to send its server port number as the next byte. The RTI will keep a record of this number in the .server_port field of the _RTI.federates[federate_id] array of structs.</dd></dl>
<p>The server_hostname and server_ip_addr fields are assigned in <a class="el" href="rti__lib_8c.html#acf8907ccab075522f7b84de579d50030">connect_to_federates()</a> upon accepting the socket from the remote federate.</p>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">federate_id</td><td>The id of the remote federate that is sending the address advertisement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0424648d3659346e9c7c645cca35d470" name="a0424648d3659346e9c7c645cca35d470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0424648d3659346e9c7c645cca35d470">&#9670;&#160;</a></span>handle_address_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_address_query </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>fed_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle address query messages. This function reads the body of a MSG_TYPE_ADDRESS_QUERY (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html">net_common.h</a>) message which is the requested destination federate ID and replies with the stored port value <a class="el" href="hashmap_8h.html#a611d52c77a8144080f7bfb45eaec2a66">for</a> the socket server of that federate. The port values are initialized to -1. If no <a class="el" href="net__common_8h.html#ae004cb4e5add42afe5483f6706e11d35">MSG_TYPE_ADDRESS_ADVERTISEMENT</a> message has been received from the destination federate, the RTI will simply reply with -1 <a class="el" href="hashmap_8h.html#a611d52c77a8144080f7bfb45eaec2a66">for</a> the port. The sending federate is responsible <a class="el" href="hashmap_8h.html#a611d52c77a8144080f7bfb45eaec2a66">for</a> checking back with the RTI after a period of time. </dd>
<dd>
<a class="el" href="federate_8h.html#a3e3a769ec47609bd5cb9fc44d51e48a4">connect_to_federate()</a> in <a class="el" href="federate_8c.html">federate.c</a>. * </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed_id</td><td>The federate sending a MSG_TYPE_ADDRESS_QUERY message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a50a2d7ea45420d332bc7444ce34518" name="a7a50a2d7ea45420d332bc7444ce34518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a50a2d7ea45420d332bc7444ce34518">&#9670;&#160;</a></span>handle_federate_resign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_federate_resign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>my_fed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function to handle messages labeled as MSG_TYPE_RESIGN sent by a federate. This message is sent at the time of termination after all shutdown events are processed on the federate.</p>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="section note"><dt>Note</dt><dd>At this point, the RTI might have outgoing messages to the federate. This function thus first performs a shutdown on the socket which sends an EOF. It then waits for the remote socket to be closed before closing the socket itself.</dd></dl>
<p>Assumptions:</p><ul>
<li>We assume that the other side (the federates) are in charge of closing the socket (by calling close() on the socket), and then wait for the RTI to shutdown the socket.</li>
<li>We assume that calling shutdown() follows the same shutdown procedure as stated in the TCP/IP specification.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">my_fed</td><td>The federate sending a MSG_TYPE_RESIGN message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bba97c8acc2b80259f8b94b01e1697d" name="a6bba97c8acc2b80259f8b94b01e1697d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bba97c8acc2b80259f8b94b01e1697d">&#9670;&#160;</a></span>handle_logical_tag_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_logical_tag_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>fed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle a logical tag complete (LTC) message. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html#a29e56d923441aac1caa2ddb4e1d604ca">MSG_TYPE_LOGICAL_TAG_COMPLETE</a> in rti.h.</dd></dl>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate that has completed a logical tag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77dee2c405d4fe62278a1cf972272bd2" name="a77dee2c405d4fe62278a1cf972272bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77dee2c405d4fe62278a1cf972272bd2">&#9670;&#160;</a></span>handle_next_event_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_next_event_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>fed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle a next event tag (NET) message. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html#af662a6a84cd64cddad92e20e26af877e">MSG_TYPE_NEXT_EVENT_TAG</a> in rti.h.</dd></dl>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate sending a NET message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5c5af408abe8a53506b2fb406046e14" name="ac5c5af408abe8a53506b2fb406046e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c5af408abe8a53506b2fb406046e14">&#9670;&#160;</a></span>handle_physical_clock_sync_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_physical_clock_sync_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>my_fed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rti__lib_8h.html#a54c375e3893ff5969d20df65b90c8335">socket_type_t</a>&#160;</td>
          <td class="paramname"><em>socket_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle clock synchronization T3 messages from federates. These will come in on the TCP channel during initialization and on the UDP channel subsequently. In both cases, this function will reply with a T4 message. If the channel is the UDP channel, then it will follow the T4 message immediately with a "coded probe" message, which will be used by the federate to decide whether to discard this clock synchronization round.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">my_fed</td><td>The sending federate. </td></tr>
    <tr><td class="paramname">socket_type</td><td>The RTI's socket type used for the communication (TCP or UDP) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6696c6969eb341c48269c2da6cec0caf" name="a6696c6969eb341c48269c2da6cec0caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6696c6969eb341c48269c2da6cec0caf">&#9670;&#160;</a></span>handle_port_absent_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_port_absent_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>sending_federate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle a port absent message being received rom a federate via the RIT.</p>
<p>This function assumes the caller does not hold the mutex. </p>

</div>
</div>
<a id="a76bea17520db7f471b8a04d20c7db5f5" name="a76bea17520db7f471b8a04d20c7db5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bea17520db7f471b8a04d20c7db5f5">&#9670;&#160;</a></span>handle_stop_request_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_stop_request_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>fed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle a MSG_TYPE_STOP_REQUEST message.</p>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate sending a MSG_TYPE_STOP_REQUEST message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa21c2b5333b021d6308a807c1f9e8844" name="aa21c2b5333b021d6308a807c1f9e8844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21c2b5333b021d6308a807c1f9e8844">&#9670;&#160;</a></span>handle_stop_request_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_stop_request_reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>fed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle a MSG_TYPE_STOP_REQUEST_REPLY message.</p>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate replying the MSG_TYPE_STOP_REQUEST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc6a599f3f5b9cf66a147b0f9ca657c8" name="afc6a599f3f5b9cf66a147b0f9ca657c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6a599f3f5b9cf66a147b0f9ca657c8">&#9670;&#160;</a></span>handle_timed_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_timed_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>sending_federate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle a timed message being received from a federate by the RTI to relay to another federate.</p>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sending_federate</td><td>The sending federate. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to read into (the first byte is already there). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cf552da2c0c98857a8f772fe19c4e9d" name="a9cf552da2c0c98857a8f772fe19c4e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf552da2c0c98857a8f772fe19c4e9d">&#9670;&#160;</a></span>handle_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_timestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>my_fed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function to handle timestamp messages. This function assumes the caller does not hold the mutex. </p>

</div>
</div>
<a id="a9569e1329c5a061249aae331a8e77403" name="a9569e1329c5a061249aae331a8e77403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9569e1329c5a061249aae331a8e77403">&#9670;&#160;</a></span>initialize_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_federate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the federate with the specified ID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The federate ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97ac8c4d61e522fc3587a7469bdc7afb" name="a97ac8c4d61e522fc3587a7469bdc7afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ac8c4d61e522fc3587a7469bdc7afb">&#9670;&#160;</a></span>mark_federate_requesting_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mark_federate_requesting_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>fed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a federate requesting stop.</p>
<p>If the number of federates handling stop reaches the NUM_OF_FEDERATES, broadcast MSG_TYPE_STOP_GRANTED to every federate.</p>
<p>This function assumes the _RTI.rti_mutex is already locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate that has requested a stop or has suddenly stopped (disconnected). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8de011aeee37cd0347b5e01d7e3baed4" name="a8de011aeee37cd0347b5e01d7e3baed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de011aeee37cd0347b5e01d7e3baed4">&#9670;&#160;</a></span>process_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process the command-line arguments. If the command line arguments are not understood, then print a usage message and return 0. Otherwise, return 1. </p><dl class="section return"><dt>Returns</dt><dd>1 if the arguments processed successfully, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a6d07d769654a6bfec790c24e1c65cd77" name="a6d07d769654a6bfec790c24e1c65cd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d07d769654a6bfec790c24e1c65cd77">&#9670;&#160;</a></span>process_clock_sync_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_clock_sync_args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process command-line arguments related to clock synchronization. Will return the last read position of argv if all related arguments are parsed or an invalid argument is read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>Number of arguments in the list </td></tr>
    <tr><td class="paramname">argv</td><td>The list of arguments as a string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current position (head) of argv; </dd></dl>

</div>
</div>
<a id="abf4f9257c2e2e4b122562b175ae0bb77" name="abf4f9257c2e2e4b122562b175ae0bb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4f9257c2e2e4b122562b175ae0bb77">&#9670;&#160;</a></span>receive_and_check_fed_id_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t receive_and_check_fed_id_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr_in *&#160;</td>
          <td class="paramname"><em>client_fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Listen for a MSG_TYPE_FED_IDS message, which includes as a payload a federate ID and a federation ID. If the federation ID matches this federation, send an MSG_TYPE_ACK and otherwise send a MSG_TYPE_REJECT message. Return 1 if the federate is accepted to the federation and 0 otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>The socket on which to listen. </td></tr>
    <tr><td class="paramname">client_fd</td><td>The socket address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The federate ID for success or -1 for failure. </dd></dl>

</div>
</div>
<a id="a001e31b4af3721b103195014d779b909" name="a001e31b4af3721b103195014d779b909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001e31b4af3721b103195014d779b909">&#9670;&#160;</a></span>receive_connection_information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int receive_connection_information </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>fed_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Listen for a MSG_TYPE_NEIGHBOR_STRUCTURE message, and upon receiving it, fill out the relevant information in the federate's struct. </p>

</div>
</div>
<a id="a31b7dee1852120f00c4f7415a84550d3" name="a31b7dee1852120f00c4f7415a84550d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b7dee1852120f00c4f7415a84550d3">&#9670;&#160;</a></span>receive_udp_message_and_set_up_clock_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int receive_udp_message_and_set_up_clock_sync </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>fed_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Listen for a MSG_TYPE_UDP_PORT message, and upon receiving it, set up clock synchronization and perform the initial clock synchronization. Initial clock synchronization is performed only if the MSG_TYPE_UDP_PORT message payload is not UINT16_MAX. If it is also not 0, then this function sets up to perform runtime clock synchronization using the UDP port number specified in the payload to communicate with the federate's clock synchronization logic. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>The socket on which to listen. </td></tr>
    <tr><td class="paramname">fed_id</td><td>The federate ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success, 0 for failure. </dd></dl>

</div>
</div>
<a id="ac6af5f2343ecf9ed87cdbebd98b94271" name="ac6af5f2343ecf9ed87cdbebd98b94271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6af5f2343ecf9ed87cdbebd98b94271">&#9670;&#160;</a></span>respond_to_erroneous_connections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * respond_to_erroneous_connections </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>nothing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread to respond to new connections, which could be federates of other federations who are attempting to join the wrong federation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nothing</td><td>Nothing needed here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70e4672b8d5c3b0e42bbb0c17d01cccd" name="a70e4672b8d5c3b0e42bbb0c17d01cccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e4672b8d5c3b0e42bbb0c17d01cccd">&#9670;&#160;</a></span>send_advance_grant_if_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool send_advance_grant_if_safe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>fed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether the specified federate fed is eligible for a tag advance grant, (TAG) and, if so, send it one. This is called upon receiving a LTC, NET or resign from an upstream federate.</p>
<p>This function calculates the minimum M over all upstream federates of the "after" delay plus the most recently received LTC from that federate. If M is greater than the most recently sent TAG to fed or greater than or equal to the most recently sent PTAG, then send a TAG(M) to fed and return.</p>
<p>If the above conditions do not result in sending a TAG, then find the minimum M of the earliest possible future message from upstream federates. This is calculated by transitively looking at the most recently received NET message from upstream federates. If M is greater than the NET of the federate fed or the most recently sent PTAG to that federate, then send TAG to the federate with tag equal to the NET of fed or the PTAG. If M is equal to the NET of the federate, then send PTAG(M).</p>
<p>This should be called whenever an immediately upstream federate sends to the RTI an LTC (Logical Tag Complete), or when a transitive upstream federate sends a NET (Next Event Tag) message. It is also called when an upstream federate resigns from the federation.</p>
<p>This function assumes that the caller holds the mutex lock.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the TAG message is sent and false otherwise. </dd></dl>

</div>
</div>
<a id="a05299fb2838277ff1f030448c9cf1ad8" name="a05299fb2838277ff1f030448c9cf1ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05299fb2838277ff1f030448c9cf1ad8">&#9670;&#160;</a></span>send_downstream_advance_grants_if_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_downstream_advance_grants_if_safe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>fed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visited</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For all federates downstream of the specified federate, determine whether they should be sent a TAG or PTAG and send it if so.</p>
<p>This assumes the caller holds the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The upstream federate. </td></tr>
    <tr><td class="paramname">visited</td><td>An array of booleans used to determine whether a federate has been visited (initially all false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a91427e9fa6a65bc44d5ec599688337" name="a6a91427e9fa6a65bc44d5ec599688337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a91427e9fa6a65bc44d5ec599688337">&#9670;&#160;</a></span>send_physical_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_physical_clock </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>message_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>fed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rti__lib_8h.html#a54c375e3893ff5969d20df65b90c8335">socket_type_t</a>&#160;</td>
          <td class="paramname"><em>socket_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a snapshot of the physical clock time and send it to federate fed_id.</p>
<p>This version assumes the caller holds the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_type</td><td>The type of the clock sync message (see <a class="el" href="net__common_8h.html">net_common.h</a>). </td></tr>
    <tr><td class="paramname">fed</td><td>The federate to send the physical time to. </td></tr>
    <tr><td class="paramname">socket_type</td><td>The socket type (TCP or UDP). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab36a04086b8af885621e5f808efecd23" name="ab36a04086b8af885621e5f808efecd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36a04086b8af885621e5f808efecd23">&#9670;&#160;</a></span>send_provisional_tag_advance_grant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_provisional_tag_advance_grant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>fed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a provisional tag advance grant (PTAG) message to the specified federate. Do not send it if a previously sent PTAG or TAG was greater or equal.</p>
<p>This function will keep a record of this PTAG in the federate's last_provisionally_granted field.</p>
<p>This function assumes that the caller holds the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to grant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a408613f224083aeba6da2c47f86006b7" name="a408613f224083aeba6da2c47f86006b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408613f224083aeba6da2c47f86006b7">&#9670;&#160;</a></span>send_reject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_reject </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>error_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a MSG_TYPE_REJECT message to the specified socket and close the socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>The socket. </td></tr>
    <tr><td class="paramname">error_code</td><td>An error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c94ce50b24ed5cc0bfce3d548d8e59f" name="a2c94ce50b24ed5cc0bfce3d548d8e59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c94ce50b24ed5cc0bfce3d548d8e59f">&#9670;&#160;</a></span>send_tag_advance_grant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_tag_advance_grant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>fed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a tag advance grant (TAG) message to the specified federate. Do not send it if a previously sent PTAG was greater or if a previously sent TAG was greater or equal.</p>
<p>This function will keep a record of this TAG in the federate's last_granted field.</p>
<p>This function assumes that the caller holds the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to grant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cc1fe69c154d09d88de1f1c06eb4b0d" name="a6cc1fe69c154d09d88de1f1c06eb4b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc1fe69c154d09d88de1f1c06eb4b0d">&#9670;&#160;</a></span>start_rti_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t start_rti_server </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the socket server for the runtime infrastructure (RTI) and return the socket descriptor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_feds</td><td>Number of federates. </td></tr>
    <tr><td class="paramname">port</td><td>The port on which to listen for socket connections, or 0 to use the default port range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa067d8ff2e12b42f8c1f011758231be1" name="aa067d8ff2e12b42f8c1f011758231be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa067d8ff2e12b42f8c1f011758231be1">&#9670;&#160;</a></span>transitive_next_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> transitive_next_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__t.html">federate_t</a> *&#160;</td>
          <td class="paramname"><em>fed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visited</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the earliest tag at which the specified federate may experience its next event. This is the least next event tag (NET) of the specified federate and (transitively) upstream federates (with delays of the connections added). For upstream federates, we assume (conservatively) that federate upstream of those may also send an event. The result will never be less than the completion time of the federate (which may be NEVER, if the federate has not yet completed a logical time).</p>
<p>FIXME: This could be made less conservative by building at code generation time a causality interface table indicating which outputs can be triggered by which inputs. For now, we assume any output can be triggered by any input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate. </td></tr>
    <tr><td class="paramname">candidate</td><td>A candidate tag (for the first invocation, this should be fed-&gt;next_event). </td></tr>
    <tr><td class="paramname">visited</td><td>An array of booleans indicating which federates have been visited (for the first invocation, this should be an array of falses of size _RTI.number_of_federates). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7190c8d1000afb0a5e8898011d041917" name="a7190c8d1000afb0a5e8898011d041917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7190c8d1000afb0a5e8898011d041917">&#9670;&#160;</a></span>update_federate_next_event_tag_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_federate_next_event_tag_locked </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>federate_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>next_event_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the next event tag of federate <code>federate_id</code>. </p>
<p>It will update the recorded next event tag of federate <code>federate_id</code> to the minimum of <code>next_event_tag</code> and the minimum tag of in-transit messages (if any) to the federate.</p>
<p>Will try to see if the RTI can grant new TAG or PTAG messages to any downstream federates based on this new next event tag.</p>
<p>This function assumes that the caller is holding the _RTI.rti_mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">federate_id</td><td>The id of the federate that needs to be updated. </td></tr>
    <tr><td class="paramname">next_event_tag</td><td>The next event tag for <code>federate_id</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb5079a0bdbc96962460a991aa880725" name="aeb5079a0bdbc96962460a991aa880725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5079a0bdbc96962460a991aa880725">&#9670;&#160;</a></span>usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a usage message. </p>

</div>
</div>
<a id="a005cb43e8e6c7795c8f0db27e2424475" name="a005cb43e8e6c7795c8f0db27e2424475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005cb43e8e6c7795c8f0db27e2424475">&#9670;&#160;</a></span>wait_for_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait_for_federates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_descriptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the runtime infrastructure (RTI) interaction with the federates and wait for the federates to exit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_descriptor</td><td>The socket descriptor returned by <a class="el" href="rti__lib_8c.html#a6cc1fe69c154d09d88de1f1c06eb4b0d">start_rti_server()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a94849214863f76b3f7c59a78bd2ad624" name="a94849214863f76b3f7c59a78bd2ad624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94849214863f76b3f7c59a78bd2ad624">&#9670;&#160;</a></span>_lf_rti_stop_granted_already_sent_to_federates</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _lf_rti_stop_granted_already_sent_to_federates = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Boolean used to prevent the RTI from sending the MSG_TYPE_STOP_GRANTED message multiple times. </p>

</div>
</div>
<a id="a104f9a0ac7ff4aa717e0462b8ac445ea" name="a104f9a0ac7ff4aa717e0462b8ac445ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104f9a0ac7ff4aa717e0462b8ac445ea">&#9670;&#160;</a></span>_RTI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_r_t_i__instance__t.html">RTI_instance_t</a> _RTI</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    .rti_mutex = PTHREAD_MUTEX_INITIALIZER,</div>
<div class="line">    .received_start_times = PTHREAD_COND_INITIALIZER,</div>
<div class="line">    .sent_start_time = PTHREAD_COND_INITIALIZER,</div>
<div class="line">    .max_stop_tag = <a class="code hl_define" href="tag_8h.html#afc2f39e1818a6a8b68ca46e7c9dc2704">NEVER_TAG</a>,</div>
<div class="line">    .max_start_time = 0LL,</div>
<div class="line">    .number_of_federates = 0,</div>
<div class="line">    .num_feds_proposed_start = 0,</div>
<div class="line">    .num_feds_handling_stop = 0,</div>
<div class="line">    .all_federates_exited = <span class="keyword">false</span>,</div>
<div class="line">    .federation_id = <span class="stringliteral">&quot;Unidentified Federation&quot;</span>,</div>
<div class="line">    .user_specified_port = 0,</div>
<div class="line">    .final_port_TCP = 0,</div>
<div class="line">    .socket_descriptor_TCP = -1,</div>
<div class="line">    .final_port_UDP = UINT16_MAX,</div>
<div class="line">    .socket_descriptor_UDP = -1,</div>
<div class="line">    .clock_sync_global_status = <a class="code hl_enumvalue" href="rti__lib_8h.html#a9705d612b9ce908ee485e92eb3f2769faf21c0b4c30338f2717ebc9f53fa34558">clock_sync_init</a>,</div>
<div class="line">    .clock_sync_period_ns = <a class="code hl_define" href="tag_8h.html#a673a8ebab8ec621a1cf731871dd170c8">MSEC</a>(10),</div>
<div class="line">    .clock_sync_exchanges_per_interval = 10,</div>
<div class="line">    .authentication_enabled = <span class="keyword">false</span></div>
<div class="line">}</div>
<div class="ttc" id="arti__lib_8h_html_a9705d612b9ce908ee485e92eb3f2769faf21c0b4c30338f2717ebc9f53fa34558"><div class="ttname"><a href="rti__lib_8h.html#a9705d612b9ce908ee485e92eb3f2769faf21c0b4c30338f2717ebc9f53fa34558">clock_sync_init</a></div><div class="ttdeci">@ clock_sync_init</div><div class="ttdef"><b>Definition:</b> rti_lib.h:132</div></div>
<div class="ttc" id="atag_8h_html_a673a8ebab8ec621a1cf731871dd170c8"><div class="ttname"><a href="tag_8h.html#a673a8ebab8ec621a1cf731871dd170c8">MSEC</a></div><div class="ttdeci">#define MSEC(t)</div><div class="ttdef"><b>Definition:</b> tag.h:45</div></div>
<div class="ttc" id="atag_8h_html_afc2f39e1818a6a8b68ca46e7c9dc2704"><div class="ttname"><a href="tag_8h.html#afc2f39e1818a6a8b68ca46e7c9dc2704">NEVER_TAG</a></div><div class="ttdeci">#define NEVER_TAG</div><div class="ttdef"><b>Definition:</b> tag.h:62</div></div>
</div><!-- fragment --><p>The state of this RTI instance. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
