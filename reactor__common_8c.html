<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: core/reactor_common.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">reactor-c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">reactor_common.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="reactor_8h_source.html">reactor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tag_8c.html">tag.c</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pqueue_8c.html">utils/pqueue.c</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pqueue__support_8h_source.html">utils/pqueue_support.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="core_2utils_2util_8c.html">utils/util.c</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="modes_8c.html">modal_models/modes.c</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad6be436dfb95ab914336870d340b207d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#ad6be436dfb95ab914336870d340b207d">_LF_TOKEN_RECYCLING_BIN_SIZE_LIMIT</a>&#160;&#160;&#160;512</td></tr>
<tr class="separator:ad6be436dfb95ab914336870d340b207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0cb4f0fedba2f1e1fd3893440ab53647"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="reactor__common_8c.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a0cb4f0fedba2f1e1fd3893440ab53647">token_freed</a></td></tr>
<tr class="separator:a0cb4f0fedba2f1e1fd3893440ab53647"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:abe23a36a87d2f0c076da417eb0114c7e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a> { <a class="el" href="reactor__common_8c.html#abe23a36a87d2f0c076da417eb0114c7ea3d7522b54086645e077eb70e78731c5c">NOT_FREED</a>
, <a class="el" href="reactor__common_8c.html#abe23a36a87d2f0c076da417eb0114c7ea417a0268666423fd955fea6f38cde238">VALUE_FREED</a>
, <a class="el" href="reactor__common_8c.html#abe23a36a87d2f0c076da417eb0114c7ea0a6094445d7a54e61aa3a43f6d017e2b">TOKEN_FREED</a>
 }</td></tr>
<tr class="separator:abe23a36a87d2f0c076da417eb0114c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afa9a756e5a6685531141bb4bfdc1f327"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#afa9a756e5a6685531141bb4bfdc1f327">_lf_allocate</a> (size_t count, size_t size, struct <a class="el" href="structallocation__record__t.html">allocation_record_t</a> **head)</td></tr>
<tr class="separator:afa9a756e5a6685531141bb4bfdc1f327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906a0d04740b6228fe3719624d11c14a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a906a0d04740b6228fe3719624d11c14a">_lf_new_reactor</a> (size_t size)</td></tr>
<tr class="separator:a906a0d04740b6228fe3719624d11c14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc6bff98286fbe73dabb8900dfa9043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#abbc6bff98286fbe73dabb8900dfa9043">_lf_free</a> (struct <a class="el" href="structallocation__record__t.html">allocation_record_t</a> **head)</td></tr>
<tr class="separator:abbc6bff98286fbe73dabb8900dfa9043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fb043a580467f2a8c14bae304db490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a19fb043a580467f2a8c14bae304db490">_lf_free_reactor</a> (struct <a class="el" href="structself__base__t.html">self_base_t</a> *self)</td></tr>
<tr class="separator:a19fb043a580467f2a8c14bae304db490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae911181dab92c081386aae7addc645e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#ae911181dab92c081386aae7addc645e7">_lf_free_all_reactors</a> (void)</td></tr>
<tr class="separator:ae911181dab92c081386aae7addc645e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e27b8e8e57c4d024a0db52043034df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#ae7e27b8e8e57c4d024a0db52043034df">_lf_set_stop_tag</a> (<a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="separator:ae7e27b8e8e57c4d024a0db52043034df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54be08fbc7990c2d8082a31cbbf6e019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a54be08fbc7990c2d8082a31cbbf6e019">get_stp_offset</a> ()</td></tr>
<tr class="separator:a54be08fbc7990c2d8082a31cbbf6e019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a5bf324229d35fb88541a04449c95b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a75a5bf324229d35fb88541a04449c95b">set_stp_offset</a> (<a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> offset)</td></tr>
<tr class="separator:a75a5bf324229d35fb88541a04449c95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2798a92c59a1d46b602298cdbd187ab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor__common_8c.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a2798a92c59a1d46b602298cdbd187ab1">_lf_free_token</a> (<a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:a2798a92c59a1d46b602298cdbd187ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c890be1f8d45461a6985cbfe6faa99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor__common_8c.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a88c890be1f8d45461a6985cbfe6faa99">_lf_done_using</a> (<a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:a88c890be1f8d45461a6985cbfe6faa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef50e4963079f2716f35c8c92256bb4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#aef50e4963079f2716f35c8c92256bb4f">_lf_trigger_reaction</a> (<a class="el" href="structreaction__t.html">reaction_t</a> *reaction, int worker_number)</td></tr>
<tr class="separator:aef50e4963079f2716f35c8c92256bb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14a3abed525c815a41a4c273937e399"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#ad14a3abed525c815a41a4c273937e399">_lf_start_time_step</a> ()</td></tr>
<tr class="separator:ad14a3abed525c815a41a4c273937e399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb98981bf2b49e5201d4233e785ac92f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#acb98981bf2b49e5201d4233e785ac92f">_lf_create_token</a> (size_t element_size)</td></tr>
<tr class="separator:acb98981bf2b49e5201d4233e785ac92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3e914b48f5f90533eecbf63acdf8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a0b3e914b48f5f90533eecbf63acdf8d9">create_token</a> (size_t element_size)</td></tr>
<tr class="separator:a0b3e914b48f5f90533eecbf63acdf8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b4b8f74714eae0efcb699281c10f87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a96b4b8f74714eae0efcb699281c10f87">_lf_initialize_token_with_value</a> (<a class="el" href="structlf__token__t.html">lf_token_t</a> *token, void *value, size_t length)</td></tr>
<tr class="separator:a96b4b8f74714eae0efcb699281c10f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55271525f5a88c650d1bce99cd137efe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a55271525f5a88c650d1bce99cd137efe">_lf_initialize_token</a> (<a class="el" href="structlf__token__t.html">lf_token_t</a> *token, size_t length)</td></tr>
<tr class="separator:a55271525f5a88c650d1bce99cd137efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d189a2e2d8b3af5f40e261f3a6b8076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a7d189a2e2d8b3af5f40e261f3a6b8076">_lf_is_tag_after_stop_tag</a> (<a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="separator:a7d189a2e2d8b3af5f40e261f3a6b8076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1ea511fbce4c80b124391d75e6ba92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#acf1ea511fbce4c80b124391d75e6ba92">_lf_pop_events</a> ()</td></tr>
<tr class="separator:acf1ea511fbce4c80b124391d75e6ba92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffc41fcd9c4870f3b01157b523a257b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#abffc41fcd9c4870f3b01157b523a257b">_lf_initialize_timer</a> (<a class="el" href="structtrigger__t.html">trigger_t</a> *timer)</td></tr>
<tr class="separator:abffc41fcd9c4870f3b01157b523a257b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa7db644ec69c067d3d6aadd2da9d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structevent__t.html">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#aeaa7db644ec69c067d3d6aadd2da9d81">_lf_get_new_event</a> ()</td></tr>
<tr class="separator:aeaa7db644ec69c067d3d6aadd2da9d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662cfd5714e5930f5e1c880f13deba6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a662cfd5714e5930f5e1c880f13deba6d">_lf_recycle_event</a> (<a class="el" href="structevent__t.html">event_t</a> *e)</td></tr>
<tr class="separator:a662cfd5714e5930f5e1c880f13deba6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb705114eb79ae21c2c3594055d0783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structevent__t.html">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#aedb705114eb79ae21c2c3594055d0783">_lf_create_dummy_events</a> (<a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a> time, <a class="el" href="structevent__t.html">event_t</a> *<a class="el" href="reactor_8c.html#a6967cbc8a4ce78b1049da429d172f90b">next</a>, <a class="el" href="platform_8h.html#aff94b88998d5bf37870fb520ad82526d">microstep_t</a> offset)</td></tr>
<tr class="separator:aedb705114eb79ae21c2c3594055d0783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392daea2eacb39e6d8b940d671949331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a392daea2eacb39e6d8b940d671949331">_lf_replace_token</a> (<a class="el" href="structevent__t.html">event_t</a> *event, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:a392daea2eacb39e6d8b940d671949331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f3a3c4613102e28fc0105408731c5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#af1f3a3c4613102e28fc0105408731c5e">_lf_schedule_at_tag</a> (<a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="structtag__t.html">tag_t</a> tag, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:af1f3a3c4613102e28fc0105408731c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d868b0a53df4f434c3d41f741dc00bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor_8h.html#a3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a2d868b0a53df4f434c3d41f741dc00bf">_lf_schedule</a> (<a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> extra_delay, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:a2d868b0a53df4f434c3d41f741dc00bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa985dff5d30c38625609d0eb356c536e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor_8h.html#a3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#aa985dff5d30c38625609d0eb356c536e">_lf_insert_reactions_for_trigger</a> (<a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:aa985dff5d30c38625609d0eb356c536e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6f924d2da176c98435f96d3bcfac6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtrigger__t.html">trigger_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#aca6f924d2da176c98435f96d3bcfac6b">_lf_action_to_trigger</a> (void *action)</td></tr>
<tr class="separator:aca6f924d2da176c98435f96d3bcfac6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadead0c4f54963b062503cf6cb7ace7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#abadead0c4f54963b062503cf6cb7ace7">_lf_advance_logical_time</a> (<a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a> next_time)</td></tr>
<tr class="separator:abadead0c4f54963b062503cf6cb7ace7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed2aef62e15386727c88c11b1737401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor_8h.html#a3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#aaed2aef62e15386727c88c11b1737401">_lf_schedule_int</a> (void *action, <a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> extra_delay, int value)</td></tr>
<tr class="separator:aaed2aef62e15386727c88c11b1737401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df90516cce7d8e01b46acf61db64b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a9df90516cce7d8e01b46acf61db64b8f">_lf_set_new_array_impl</a> (<a class="el" href="structlf__token__t.html">lf_token_t</a> *token, size_t length, int num_destinations)</td></tr>
<tr class="separator:a9df90516cce7d8e01b46acf61db64b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6f96af2d1adbf71c57586a9078f248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a6a6f96af2d1adbf71c57586a9078f248">_lf_check_deadline</a> (<a class="el" href="structself__base__t.html">self_base_t</a> *self, <a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> invoke_deadline_handler)</td></tr>
<tr class="separator:a6a6f96af2d1adbf71c57586a9078f248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6043f620d4c10e7aed87f64499212ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a6043f620d4c10e7aed87f64499212ecf">_lf_invoke_reaction</a> (<a class="el" href="structreaction__t.html">reaction_t</a> *reaction, int <a class="el" href="reactor__threaded_8c.html#a15b16453216ed29570af03009e7c7c63">worker</a>)</td></tr>
<tr class="separator:a6043f620d4c10e7aed87f64499212ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615a0670be544780678a1940a49c8d1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a615a0670be544780678a1940a49c8d1e">schedule_output_reactions</a> (<a class="el" href="structreaction__t.html">reaction_t</a> *reaction, int <a class="el" href="reactor__threaded_8c.html#a15b16453216ed29570af03009e7c7c63">worker</a>)</td></tr>
<tr class="separator:a615a0670be544780678a1940a49c8d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b23ae956bad82624233eafa837affb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#ab8b23ae956bad82624233eafa837affb">writable_copy</a> (<a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:ab8b23ae956bad82624233eafa837affb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5079a0bdbc96962460a991aa880725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#aeb5079a0bdbc96962460a991aa880725">usage</a> (int argc, char *argv[])</td></tr>
<tr class="separator:aeb5079a0bdbc96962460a991aa880725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de011aeee37cd0347b5e01d7e3baed4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a8de011aeee37cd0347b5e01d7e3baed4">process_args</a> (int argc, char *argv[])</td></tr>
<tr class="separator:a8de011aeee37cd0347b5e01d7e3baed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efe22aaead3a5e936b5df459de02eba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a9efe22aaead3a5e936b5df459de02eba">initialize</a> (void)</td></tr>
<tr class="separator:a9efe22aaead3a5e936b5df459de02eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa329f59a16f5617b5195f2c05872c9e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#aa329f59a16f5617b5195f2c05872c9e9">termination</a> (void)</td></tr>
<tr class="separator:aa329f59a16f5617b5195f2c05872c9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9c91e5c84c3910df17c909ccdea074db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a9c91e5c84c3910df17c909ccdea074db">fast</a> = <a class="el" href="lf__windows__support_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="separator:a9c91e5c84c3910df17c909ccdea074db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fd0d1404992f7d875791a764a26925"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a01fd0d1404992f7d875791a764a26925">_lf_number_of_workers</a> = 0u</td></tr>
<tr class="separator:a01fd0d1404992f7d875791a764a26925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1211ca2b5b848ae700471d1ab0177709"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreaction__t.html">reaction_t</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a1211ca2b5b848ae700471d1ab0177709">_lf_startup_reactions</a></td></tr>
<tr class="separator:a1211ca2b5b848ae700471d1ab0177709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565a9ac648fb05c803b1d7fffe2dedd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a565a9ac648fb05c803b1d7fffe2dedd2">_lf_startup_reactions_size</a></td></tr>
<tr class="separator:a565a9ac648fb05c803b1d7fffe2dedd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8079fdfadf07cba8a660c9c25cb9dc77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a8079fdfadf07cba8a660c9c25cb9dc77">duration</a> = -1LL</td></tr>
<tr class="separator:a8079fdfadf07cba8a660c9c25cb9dc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac6e1f16371ec26c509b7ad375d6334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#abac6e1f16371ec26c509b7ad375d6334">_lf_execution_started</a> = <a class="el" href="lf__windows__support_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="separator:abac6e1f16371ec26c509b7ad375d6334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007aadaac39cca4ce69656a91b5e236c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a007aadaac39cca4ce69656a91b5e236c">stop_tag</a> = <a class="el" href="tag_8h.html#a33ccb2b8fb9f20ab29ea298b9051443a">FOREVER_TAG_INITIALIZER</a></td></tr>
<tr class="separator:a007aadaac39cca4ce69656a91b5e236c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e69bf5802b3968ed00af688cc7a8006"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a3e69bf5802b3968ed00af688cc7a8006">keepalive_specified</a> = <a class="el" href="lf__windows__support_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="separator:a3e69bf5802b3968ed00af688cc7a8006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfed2c6141fd2a9d381ecde48c1798fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#acfed2c6141fd2a9d381ecde48c1798fa">_lf_is_present_fields</a> = NULL</td></tr>
<tr class="separator:acfed2c6141fd2a9d381ecde48c1798fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e3286d5bce5d0f68e814e5be1afa94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a62e3286d5bce5d0f68e814e5be1afa94">_lf_is_present_fields_size</a> = 0</td></tr>
<tr class="separator:a62e3286d5bce5d0f68e814e5be1afa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec27b9fa274d0489bf34449417f8441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#adec27b9fa274d0489bf34449417f8441">_lf_is_present_fields_abbreviated</a> = NULL</td></tr>
<tr class="separator:adec27b9fa274d0489bf34449417f8441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f62454f96951f5bf8e43ffa17d80afc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a3f62454f96951f5bf8e43ffa17d80afc">_lf_is_present_fields_abbreviated_size</a> = 0</td></tr>
<tr class="separator:a3f62454f96951f5bf8e43ffa17d80afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bf168ab25a09620bc0d1f9fe0547b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#ac5bf168ab25a09620bc0d1f9fe0547b3">_lf_intended_tag_fields</a> = NULL</td></tr>
<tr class="separator:ac5bf168ab25a09620bc0d1f9fe0547b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d60ce16c0f0a9b139856b9f2a6c463"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a86d60ce16c0f0a9b139856b9f2a6c463">_lf_intended_tag_fields_size</a> = 0</td></tr>
<tr class="separator:a86d60ce16c0f0a9b139856b9f2a6c463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8e15db9bf3b081c3f084d1e1a3b043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtoken__present__t.html">token_present_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a3e8e15db9bf3b081c3f084d1e1a3b043">_lf_tokens_with_ref_count</a> = NULL</td></tr>
<tr class="separator:a3e8e15db9bf3b081c3f084d1e1a3b043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10daeb6bf7d37ada7a878859a34ed5ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a10daeb6bf7d37ada7a878859a34ed5ed">_lf_more_tokens_with_ref_count</a> = NULL</td></tr>
<tr class="separator:a10daeb6bf7d37ada7a878859a34ed5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf357e4cd193ba66ac15262992e2a9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a0bf357e4cd193ba66ac15262992e2a9b">_lf_tokens_with_ref_count_size</a> = 0</td></tr>
<tr class="separator:a0bf357e4cd193ba66ac15262992e2a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f588e1df453139dbb9a4157dda2027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a39f588e1df453139dbb9a4157dda2027">_lf_global_time_STP_offset</a> = 0LL</td></tr>
<tr class="separator:a39f588e1df453139dbb9a4157dda2027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b5bfd131da48f0fb95eab14e6e61c8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structallocation__record__t.html">allocation_record_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#af4b5bfd131da48f0fb95eab14e6e61c8">_lf_reactors_to_free</a> = NULL</td></tr>
<tr class="separator:af4b5bfd131da48f0fb95eab14e6e61c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5336de38071181906a15eccf873858fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpqueue__t.html">pqueue_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a5336de38071181906a15eccf873858fe">event_q</a></td></tr>
<tr class="separator:a5336de38071181906a15eccf873858fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209e679d16efc35de4ffc5e1c68bafdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpqueue__t.html">pqueue_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a209e679d16efc35de4ffc5e1c68bafdf">recycle_q</a></td></tr>
<tr class="separator:a209e679d16efc35de4ffc5e1c68bafdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3015ddee9b93cc02c05fd721efb528a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpqueue__t.html">pqueue_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a3015ddee9b93cc02c05fd721efb528a4">next_q</a></td></tr>
<tr class="separator:a3015ddee9b93cc02c05fd721efb528a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704e33dea85c02402f0e8f6fde6eb807"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor_8h.html#a3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a704e33dea85c02402f0e8f6fde6eb807">_lf_handle</a> = 1</td></tr>
<tr class="separator:a704e33dea85c02402f0e8f6fde6eb807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3d09c9be6e01e4f3e7610ef696d04c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a0e3d09c9be6e01e4f3e7610ef696d04c">_lf_token_recycling_bin</a> = NULL</td></tr>
<tr class="separator:a0e3d09c9be6e01e4f3e7610ef696d04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d4f18784a333cacd808c3b5927eff4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a36d4f18784a333cacd808c3b5927eff4">_lf_token_recycling_bin_size</a> = 0</td></tr>
<tr class="separator:a36d4f18784a333cacd808c3b5927eff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab46895a3a4d1341a19b689a0ea902d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#aab46895a3a4d1341a19b689a0ea902d1">default_argc</a> = 0</td></tr>
<tr class="separator:aab46895a3a4d1341a19b689a0ea902d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079c42a8611d008395dba5af4911e85c"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8c.html#a079c42a8611d008395dba5af4911e85c">default_argv</a> = NULL</td></tr>
<tr class="separator:a079c42a8611d008395dba5af4911e85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad6be436dfb95ab914336870d340b207d" name="ad6be436dfb95ab914336870d340b207d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6be436dfb95ab914336870d340b207d">&#9670;&nbsp;</a></span>_LF_TOKEN_RECYCLING_BIN_SIZE_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _LF_TOKEN_RECYCLING_BIN_SIZE_LIMIT&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >To allow a system to recover from burst of activity, the token recycling bin has a limited size. When it becomes full, token are freed using <a class="el" href="hashmap_8c.html#a124050fa63c3161a5ae1ea701cf4e599">free()</a>. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0cb4f0fedba2f1e1fd3893440ab53647" name="a0cb4f0fedba2f1e1fd3893440ab53647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb4f0fedba2f1e1fd3893440ab53647">&#9670;&nbsp;</a></span>token_freed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="reactor__common_8c.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a> <a class="el" href="reactor__common_8c.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Possible return values for _lf_done_using. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abe23a36a87d2f0c076da417eb0114c7e" name="abe23a36a87d2f0c076da417eb0114c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe23a36a87d2f0c076da417eb0114c7e">&#9670;&nbsp;</a></span>token_freed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="reactor__common_8c.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Possible return values for _lf_done_using. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abe23a36a87d2f0c076da417eb0114c7ea3d7522b54086645e077eb70e78731c5c" name="abe23a36a87d2f0c076da417eb0114c7ea3d7522b54086645e077eb70e78731c5c"></a>NOT_FREED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abe23a36a87d2f0c076da417eb0114c7ea417a0268666423fd955fea6f38cde238" name="abe23a36a87d2f0c076da417eb0114c7ea417a0268666423fd955fea6f38cde238"></a>VALUE_FREED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abe23a36a87d2f0c076da417eb0114c7ea0a6094445d7a54e61aa3a43f6d017e2b" name="abe23a36a87d2f0c076da417eb0114c7ea0a6094445d7a54e61aa3a43f6d017e2b"></a>TOKEN_FREED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aca6f924d2da176c98435f96d3bcfac6b" name="aca6f924d2da176c98435f96d3bcfac6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6f924d2da176c98435f96d3bcfac6b">&#9670;&nbsp;</a></span>_lf_action_to_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtrigger__t.html">trigger_t</a> * _lf_action_to_trigger </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility function to convert a pointer to action struct into a pointer to the corresponding trigger struct. The type of the action struct is defined by a generated typedef and differs for different actions, which is why the point to the action struct is a void*. All such structs, however, share a common feature, which is tht the first entry in the struct is a pointer to the corresponding <a class="el" href="structtrigger__t.html">trigger_t</a> struct. This function uses this fact to return a pointer to that <a class="el" href="structtrigger__t.html">trigger_t</a> struct. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>A pointer to an action struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the corresponding trigger struct. </dd></dl>

</div>
</div>
<a id="abadead0c4f54963b062503cf6cb7ace7" name="abadead0c4f54963b062503cf6cb7ace7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abadead0c4f54963b062503cf6cb7ace7">&#9670;&nbsp;</a></span>_lf_advance_logical_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_advance_logical_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a>&#160;</td>
          <td class="paramname"><em>next_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Advance from the current tag to the next. If the given next_time is equal to the current time, then increase the microstep. Otherwise, update the current time and set the microstep to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_time</td><td>The time step to advance to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa9a756e5a6685531141bb4bfdc1f327" name="afa9a756e5a6685531141bb4bfdc1f327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9a756e5a6685531141bb4bfdc1f327">&#9670;&nbsp;</a></span>_lf_allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * _lf_allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structallocation__record__t.html">allocation_record_t</a> **&#160;</td>
          <td class="paramname"><em>head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocate memory using calloc (so the allocated memory is zeroed out) and record the allocated memory on the specified self struct so that it will be freed when calling <code><a class="el" href="">free_reactor(self_base_t)</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of items of size 'size' to accomodate. </td></tr>
    <tr><td class="paramname">size</td><td>The size of each item. </td></tr>
    <tr><td class="paramname">head</td><td>Pointer to the head of a list on which to record the allocation, or NULL to not record it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a6f96af2d1adbf71c57586a9078f248" name="a6a6f96af2d1adbf71c57586a9078f248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6f96af2d1adbf71c57586a9078f248">&#9670;&nbsp;</a></span>_lf_check_deadline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> _lf_check_deadline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structself__base__t.html">self_base_t</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>&#160;</td>
          <td class="paramname"><em>invoke_deadline_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check the deadline of the currently executing reaction against the current physical time. If the deadline has passed, invoke the deadline handler (if invoke_deadline_handler parameter is set true) and return true. Otherwise, return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The self struct of the reactor. </td></tr>
    <tr><td class="paramname">invoke_deadline_handler</td><td>When this is set true, also invoke deadline handler if the deadline has passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified deadline has passed and false otherwise. </dd></dl>

</div>
</div>
<a id="aedb705114eb79ae21c2c3594055d0783" name="aedb705114eb79ae21c2c3594055d0783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb705114eb79ae21c2c3594055d0783">&#9670;&nbsp;</a></span>_lf_create_dummy_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structevent__t.html">event_t</a> * _lf_create_dummy_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structevent__t.html">event_t</a> *&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#aff94b88998d5bf37870fb520ad82526d">microstep_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create dummy events to be used as spacers in the event queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>The eventual event to be triggered. </td></tr>
    <tr><td class="paramname">time</td><td>The logical time of that event. </td></tr>
    <tr><td class="paramname">next</td><td>The event to place after the dummy events. </td></tr>
    <tr><td class="paramname">offset</td><td>The number of dummy events to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first dummy event. </dd></dl>

</div>
</div>
<a id="acb98981bf2b49e5201d4233e785ac92f" name="acb98981bf2b49e5201d4233e785ac92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb98981bf2b49e5201d4233e785ac92f">&#9670;&nbsp;</a></span>_lf_create_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * _lf_create_token </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a new <a class="el" href="structlf__token__t.html">lf_token_t</a> struct and initialize it for assignment to a trigger. The value pointer will be NULL and the length will be 0. This function is for tokens that are not expected to be freed, and reactors are not expected to use it. It is used by the code generator to initialize actions with tokens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_size</td><td>The size of an element carried in the payload or 0 if there is no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new or recycled <a class="el" href="structlf__token__t.html">lf_token_t</a> struct. </dd></dl>

</div>
</div>
<a id="a88c890be1f8d45461a6985cbfe6faa99" name="a88c890be1f8d45461a6985cbfe6faa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c890be1f8d45461a6985cbfe6faa99">&#9670;&nbsp;</a></span>_lf_done_using()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor__common_8c.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a> _lf_done_using </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Decrement the reference count of the specified token. If the reference count hits 0, free the memory for the value carried by the token, and, if the token is not also the template token of its trigger, free the token. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>Pointer to a token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOT_FREED if nothing was freed, VALUE_FREED if the value was freed, and TOKEN_FREED if both the value and the token were freed. </dd></dl>

</div>
</div>
<a id="abbc6bff98286fbe73dabb8900dfa9043" name="abbc6bff98286fbe73dabb8900dfa9043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc6bff98286fbe73dabb8900dfa9043">&#9670;&nbsp;</a></span>_lf_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structallocation__record__t.html">allocation_record_t</a> **&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Free memory allocated using <code><a class="el" href="reactor__common_8c.html#afa9a756e5a6685531141bb4bfdc1f327">_lf_allocate(size_t, size_t, allocation_record_t**)</a></code> and mark the list empty by setting <code>*head</code> to NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of a list on which to record the allocation, or NULL to not record it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae911181dab92c081386aae7addc645e7" name="ae911181dab92c081386aae7addc645e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae911181dab92c081386aae7addc645e7">&#9670;&nbsp;</a></span>_lf_free_all_reactors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_free_all_reactors </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Free all the reactors that are allocated with <code><a class="el" href="reactor__common_8c.html#a906a0d04740b6228fe3719624d11c14a">_lf_new_reactor(size_t)</a></code>. </p>

</div>
</div>
<a id="a19fb043a580467f2a8c14bae304db490" name="a19fb043a580467f2a8c14bae304db490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fb043a580467f2a8c14bae304db490">&#9670;&nbsp;</a></span>_lf_free_reactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_free_reactor </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structself__base__t.html">self_base_t</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Free memory recorded on the allocations list of the specified reactor and then free the specified self struct. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The self struct of the reactor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2798a92c59a1d46b602298cdbd187ab1" name="a2798a92c59a1d46b602298cdbd187ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2798a92c59a1d46b602298cdbd187ab1">&#9670;&nbsp;</a></span>_lf_free_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor__common_8c.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a> _lf_free_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine which part of the token should be freed and free each part correspondingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>Pointer to a token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOT_FREED if nothing was freed, VALUE_FREED if the value was freed, and TOKEN_FREED if both the value and the token were freed. </dd></dl>

</div>
</div>
<a id="aeaa7db644ec69c067d3d6aadd2da9d81" name="aeaa7db644ec69c067d3d6aadd2da9d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa7db644ec69c067d3d6aadd2da9d81">&#9670;&nbsp;</a></span>_lf_get_new_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structevent__t.html">event_t</a> * _lf_get_new_event </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get a new event. If there is a recycled event available, use that. If not, allocate a new one. In either case, all fields will be zero'ed out. </p>

</div>
</div>
<a id="abffc41fcd9c4870f3b01157b523a257b" name="abffc41fcd9c4870f3b01157b523a257b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffc41fcd9c4870f3b01157b523a257b">&#9670;&nbsp;</a></span>_lf_initialize_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_initialize_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize the given timer. If this timer has a zero offset, enqueue the reactions it triggers. If this timer is to trigger reactions at a <em>future</em> tag as well, schedule it accordingly. </p>

</div>
</div>
<a id="a55271525f5a88c650d1bce99cd137efe" name="a55271525f5a88c650d1bce99cd137efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55271525f5a88c650d1bce99cd137efe">&#9670;&nbsp;</a></span>_lf_initialize_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * _lf_initialize_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a token for storing an array of the specified length with new memory allocated (using malloc) for storing that array. If the specified token is available (its reference count is 0), then reuse it. Otherwise, create a new token. The element_size for elements of the array is specified by the specified token. The caller should populate the value and ref_count field of the returned token after this returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token to populate, if it is available (must not be NULL). </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array, or 1 if it is not an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either the specified token or a new one, in each case with a value field pointing to newly allocated memory. </dd></dl>

</div>
</div>
<a id="a96b4b8f74714eae0efcb699281c10f87" name="a96b4b8f74714eae0efcb699281c10f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b4b8f74714eae0efcb699281c10f87">&#9670;&nbsp;</a></span>_lf_initialize_token_with_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * _lf_initialize_token_with_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a token for storing an array of the specified length with the specified value containing the array. If the specified token is available (its reference count is 0), then reuse it. Otherwise, create a new token. The element_size for elements of the array is specified by the specified token.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token to populate, if it is available (must not be NULL). </td></tr>
    <tr><td class="paramname">value</td><td>The value of the array. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array, or 1 if it is not an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either the specified token or a new one, in each case with a value field pointing to newly allocated memory. </dd></dl>

</div>
</div>
<a id="aa985dff5d30c38625609d0eb356c536e" name="aa985dff5d30c38625609d0eb356c536e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa985dff5d30c38625609d0eb356c536e">&#9670;&nbsp;</a></span>_lf_insert_reactions_for_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor_8h.html#a3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> _lf_insert_reactions_for_trigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Insert reactions triggered by trigger to the reaction queue...</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>The trigger </td></tr>
    <tr><td class="paramname">token</td><td>The token wrapping the payload or NULL for no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, or 0 if no new reaction was scheduled because the function was called incorrectly. </dd></dl>

</div>
</div>
<a id="a6043f620d4c10e7aed87f64499212ecf" name="a6043f620d4c10e7aed87f64499212ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6043f620d4c10e7aed87f64499212ecf">&#9670;&nbsp;</a></span>_lf_invoke_reaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_invoke_reaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreaction__t.html">reaction_t</a> *&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>worker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Invoke the given reaction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reaction</td><td>The reaction that has just executed. </td></tr>
    <tr><td class="paramname">worker</td><td>The thread number of the worker thread or 0 for unthreaded execution (for tracing). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d189a2e2d8b3af5f40e261f3a6b8076" name="a7d189a2e2d8b3af5f40e261f3a6b8076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d189a2e2d8b3af5f40e261f3a6b8076">&#9670;&nbsp;</a></span>_lf_is_tag_after_stop_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> _lf_is_tag_after_stop_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A helper function that returns true if the provided tag is after stop tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag to check against stop tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a906a0d04740b6228fe3719624d11c14a" name="a906a0d04740b6228fe3719624d11c14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906a0d04740b6228fe3719624d11c14a">&#9670;&nbsp;</a></span>_lf_new_reactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * _lf_new_reactor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocate memory for a new runtime instance of a reactor. This records the reactor on the list of reactors to be freed at termination of the program. If you plan to free the reactor before termination of the program, use calloc instead (which this uses). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the self struct, obtained with sizeof(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf1ea511fbce4c80b124391d75e6ba92" name="acf1ea511fbce4c80b124391d75e6ba92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1ea511fbce4c80b124391d75e6ba92">&#9670;&nbsp;</a></span>_lf_pop_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_pop_events </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Pop all events from event_q with timestamp equal to current_tag.time, extract all the reactions triggered by these events, and stick them into the reaction queue. </p>

</div>
</div>
<a id="a662cfd5714e5930f5e1c880f13deba6d" name="a662cfd5714e5930f5e1c880f13deba6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662cfd5714e5930f5e1c880f13deba6d">&#9670;&nbsp;</a></span>_lf_recycle_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_recycle_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__t.html">event_t</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Recycle the given event. Zero it out and pushed it onto the recycle queue. </p>

</div>
</div>
<a id="a392daea2eacb39e6d8b940d671949331" name="a392daea2eacb39e6d8b940d671949331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392daea2eacb39e6d8b940d671949331">&#9670;&nbsp;</a></span>_lf_replace_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_replace_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__t.html">event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Replace the token on the specified event with the specified token and free the old token. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event. </td></tr>
    <tr><td class="paramname">token</td><td>The token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d868b0a53df4f434c3d41f741dc00bf" name="a2d868b0a53df4f434c3d41f741dc00bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d868b0a53df4f434c3d41f741dc00bf">&#9670;&nbsp;</a></span>_lf_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor_8h.html#a3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> _lf_schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>extra_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Schedule the specified trigger at current_tag.time plus the offset of the specified trigger plus the delay. See <a class="el" href="schedule_8c.html#a738008e8a7b26ec1319c6375700e2e35">schedule_token()</a> in <a class="el" href="reactor_8h.html">reactor.h</a> for details. This is the internal implementation shared by both the threaded and non-threaded versions.</p>
<p >The value is required to be either NULL or a pointer to a token wrapping the payload. The token carries a reference count, and when the reference count decrements to 0, the will be freed. Hence, it is essential that the payload be in memory allocated using malloc.</p>
<p >There are three conditions under which this function will not actually put an event on the event queue and decrement the reference count of the token (if there is one), which could result in the payload being freed. In all three cases, this function returns 0. Otherwise, it returns a handle to the scheduled trigger, which is an integer greater than 0.</p>
<p >The first condition is that a stop has been requested and the trigger offset plus the extra delay is greater than zero. The second condition is that the trigger offset plus the extra delay is greater that the requested stop time (timeout). The third condition is that the trigger argument is null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>The trigger to be invoked at a later logical time. </td></tr>
    <tr><td class="paramname">extra_delay</td><td>The logical time delay, which gets added to the trigger's minimum delay, if it has one. If this number is negative, then zero is used instead. </td></tr>
    <tr><td class="paramname">token</td><td>The token wrapping the payload or NULL for no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no new event was scheduled, or -1 for error. </dd></dl>

</div>
</div>
<a id="af1f3a3c4613102e28fc0105408731c5e" name="af1f3a3c4613102e28fc0105408731c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f3a3c4613102e28fc0105408731c5e">&#9670;&nbsp;</a></span>_lf_schedule_at_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_schedule_at_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Schedule events at a specific tag (time, microstep), provided that the tag is in the future relative to the current tag. The input time values are absolute.</p>
<p >If there is an event found at the requested tag, the payload is replaced and 0 is returned.</p>
<p >Note that this function is an internal API that must be called with tags that are in order for a given trigger. This means that the following order is illegal: _lf_schedule_at_tag(trigger1, bigger_tag, ...); _lf_schedule_at_tag(trigger1, smaller_tag, ...); where bigger_tag &gt; smaller_tag. This function is primarily used for network communication (which is assumed to be in order).</p>
<p >This function assumes the caller holds the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>The trigger to be invoked at a later logical time. </td></tr>
    <tr><td class="paramname">tag</td><td>Logical tag of the event </td></tr>
    <tr><td class="paramname">token</td><td>The token wrapping the payload or NULL for no payload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success, 0 if no new event was scheduled (instead, the payload was updated), or -1 for error (the tag is equal to or less than the current tag). </dd></dl>

</div>
</div>
<a id="aaed2aef62e15386727c88c11b1737401" name="aaed2aef62e15386727c88c11b1737401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed2aef62e15386727c88c11b1737401">&#9670;&nbsp;</a></span>_lf_schedule_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor_8h.html#a3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> _lf_schedule_int </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>extra_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Variant of schedule_value when the value is an integer. See <a class="el" href="reactor_8h.html">reactor.h</a> for documentation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>Pointer to an action on the self struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9df90516cce7d8e01b46acf61db64b8f" name="a9df90516cce7d8e01b46acf61db64b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df90516cce7d8e01b46acf61db64b8f">&#9670;&nbsp;</a></span>_lf_set_new_array_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * _lf_set_new_array_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_destinations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Library function for allocating memory for an array to be sent on an output. This turns over "ownership" of the allocated memory to the output, so the allocated memory will be freed downstream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token to use as a template (or if it is free, to use). </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array. </td></tr>
    <tr><td class="paramname">num_destinations</td><td>The number of destinations (for initializing the reference count). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new or reused token or null if the template token is incompatible with this usage. </dd></dl>

</div>
</div>
<a id="ae7e27b8e8e57c4d024a0db52043034df" name="ae7e27b8e8e57c4d024a0db52043034df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e27b8e8e57c4d024a0db52043034df">&#9670;&nbsp;</a></span>_lf_set_stop_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_set_stop_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the stop tag.</p>
<p >This function will always choose the minimum of the provided tag and stop_tag</p>
<dl class="section note"><dt>Note</dt><dd>In threaded programs, the mutex must be locked before calling this function. </dd></dl>

</div>
</div>
<a id="ad14a3abed525c815a41a4c273937e399" name="ad14a3abed525c815a41a4c273937e399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14a3abed525c815a41a4c273937e399">&#9670;&nbsp;</a></span>_lf_start_time_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_start_time_step </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Use tables to reset is_present fields to false, set intended_tag fields in federated execution to the current_tag, and decrement reference counts between time steps and at the end of execution. </p>

</div>
</div>
<a id="aef50e4963079f2716f35c8c92256bb4f" name="aef50e4963079f2716f35c8c92256bb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef50e4963079f2716f35c8c92256bb4f">&#9670;&nbsp;</a></span>_lf_trigger_reaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_trigger_reaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreaction__t.html">reaction_t</a> *&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>worker_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Trigger 'reaction'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reaction</td><td>The reaction. </td></tr>
    <tr><td class="paramname">worker_number</td><td>The ID of the worker that is making this call. 0 should be used if there is only one worker (e.g., when the program is using the unthreaded C runtime). -1 is used for an anonymous call in a context where a worker number does not make sense (e.g., the caller is not a worker thread). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b3e914b48f5f90533eecbf63acdf8d9" name="a0b3e914b48f5f90533eecbf63acdf8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3e914b48f5f90533eecbf63acdf8d9">&#9670;&nbsp;</a></span>create_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * create_token </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a new token and initialize it. The value pointer will be NULL and the length will be 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_size</td><td>The size of an element carried in the payload or 0 if there is no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new or recycled <a class="el" href="structlf__token__t.html">lf_token_t</a> struct.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For multithreaded applications, the caller must hold the mutex lock because it accesses global variables. </dd></dl>

</div>
</div>
<a id="a54be08fbc7990c2d8082a31cbbf6e019" name="a54be08fbc7990c2d8082a31cbbf6e019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54be08fbc7990c2d8082a31cbbf6e019">&#9670;&nbsp;</a></span>get_stp_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> get_stp_offset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the global STP offset on advancement of logical time for federated execution. </p>

</div>
</div>
<a id="a9efe22aaead3a5e936b5df459de02eba" name="a9efe22aaead3a5e936b5df459de02eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efe22aaead3a5e936b5df459de02eba">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize the priority queues and set logical time to match physical time. This also prints a message reporting the start time. </p>

</div>
</div>
<a id="a8de011aeee37cd0347b5e01d7e3baed4" name="a8de011aeee37cd0347b5e01d7e3baed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de011aeee37cd0347b5e01d7e3baed4">&#9670;&nbsp;</a></span>process_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Process the command-line arguments. If the command line arguments are not understood, then print a usage message and return 0. Otherwise, return 1. </p><dl class="section return"><dt>Returns</dt><dd>1 if the arguments processed successfully, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a615a0670be544780678a1940a49c8d1e" name="a615a0670be544780678a1940a49c8d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615a0670be544780678a1940a49c8d1e">&#9670;&nbsp;</a></span>schedule_output_reactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule_output_reactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreaction__t.html">reaction_t</a> *&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>worker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >For the specified reaction, if it has produced outputs, insert the resulting triggered reactions into the reaction queue. This procedure assumes the mutex lock is NOT held and grabs the lock only when it actually inserts something onto the reaction queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reaction</td><td>The reaction that has just executed. </td></tr>
    <tr><td class="paramname">worker</td><td>The thread number of the worker thread or 0 for unthreaded execution (for tracing). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75a5bf324229d35fb88541a04449c95b" name="a75a5bf324229d35fb88541a04449c95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a5bf324229d35fb88541a04449c95b">&#9670;&nbsp;</a></span>set_stp_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_stp_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the global STP offset on advancement of logical time for federated execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>A positive time value to be applied as the STP offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa329f59a16f5617b5195f2c05872c9e9" name="aa329f59a16f5617b5195f2c05872c9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa329f59a16f5617b5195f2c05872c9e9">&#9670;&nbsp;</a></span>termination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void termination </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Report elapsed logical and physical times and report if any memory allocated by set_new, set_new_array, or writable_copy has not been freed. </p>

</div>
</div>
<a id="aeb5079a0bdbc96962460a991aa880725" name="aeb5079a0bdbc96962460a991aa880725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5079a0bdbc96962460a991aa880725">&#9670;&nbsp;</a></span>usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print a usage message. </p>

</div>
</div>
<a id="ab8b23ae956bad82624233eafa837affb" name="ab8b23ae956bad82624233eafa837affb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b23ae956bad82624233eafa837affb">&#9670;&nbsp;</a></span>writable_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * writable_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a writable copy of the specified token. If the reference count is 1, this returns the original token rather than a copy. The reference count will still be 1. If the size of the token payload is zero, this also returns the original token. Otherwise, this returns a new token with a reference count of 0. To ensure that the allocated memory is not leaked, this new token must be either passed to an output using set_token() or scheduled with a action using <a class="el" href="schedule_8c.html#a738008e8a7b26ec1319c6375700e2e35">schedule_token()</a>. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abac6e1f16371ec26c509b7ad375d6334" name="abac6e1f16371ec26c509b7ad375d6334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac6e1f16371ec26c509b7ad375d6334">&#9670;&nbsp;</a></span>_lf_execution_started</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> _lf_execution_started = <a class="el" href="lf__windows__support_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Indicates whether or not the execution has started. </p>

</div>
</div>
<a id="a39f588e1df453139dbb9a4157dda2027" name="a39f588e1df453139dbb9a4157dda2027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f588e1df453139dbb9a4157dda2027">&#9670;&nbsp;</a></span>_lf_global_time_STP_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> _lf_global_time_STP_offset = 0LL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Global STP offset uniformly applied to advancement of each time step in federated execution. This can be retrieved in user code by calling <a class="el" href="reactor__common_8c.html#a54be08fbc7990c2d8082a31cbbf6e019">get_stp_offset()</a> and adjusted by calling <a class="el" href="reactor__common_8c.html#a75a5bf324229d35fb88541a04449c95b">set_stp_offset(interval_t offset)</a>. </p>

</div>
</div>
<a id="a704e33dea85c02402f0e8f6fde6eb807" name="a704e33dea85c02402f0e8f6fde6eb807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704e33dea85c02402f0e8f6fde6eb807">&#9670;&nbsp;</a></span>_lf_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor_8h.html#a3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> _lf_handle = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5bf168ab25a09620bc0d1f9fe0547b3" name="ac5bf168ab25a09620bc0d1f9fe0547b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bf168ab25a09620bc0d1f9fe0547b3">&#9670;&nbsp;</a></span>_lf_intended_tag_fields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a>** _lf_intended_tag_fields = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86d60ce16c0f0a9b139856b9f2a6c463" name="a86d60ce16c0f0a9b139856b9f2a6c463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d60ce16c0f0a9b139856b9f2a6c463">&#9670;&nbsp;</a></span>_lf_intended_tag_fields_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_intended_tag_fields_size = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acfed2c6141fd2a9d381ecde48c1798fa" name="acfed2c6141fd2a9d381ecde48c1798fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfed2c6141fd2a9d381ecde48c1798fa">&#9670;&nbsp;</a></span>_lf_is_present_fields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>** _lf_is_present_fields = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adec27b9fa274d0489bf34449417f8441" name="adec27b9fa274d0489bf34449417f8441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec27b9fa274d0489bf34449417f8441">&#9670;&nbsp;</a></span>_lf_is_present_fields_abbreviated</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a>** _lf_is_present_fields_abbreviated = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f62454f96951f5bf8e43ffa17d80afc" name="a3f62454f96951f5bf8e43ffa17d80afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f62454f96951f5bf8e43ffa17d80afc">&#9670;&nbsp;</a></span>_lf_is_present_fields_abbreviated_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_is_present_fields_abbreviated_size = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62e3286d5bce5d0f68e814e5be1afa94" name="a62e3286d5bce5d0f68e814e5be1afa94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e3286d5bce5d0f68e814e5be1afa94">&#9670;&nbsp;</a></span>_lf_is_present_fields_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_is_present_fields_size = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10daeb6bf7d37ada7a878859a34ed5ed" name="a10daeb6bf7d37ada7a878859a34ed5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10daeb6bf7d37ada7a878859a34ed5ed">&#9670;&nbsp;</a></span>_lf_more_tokens_with_ref_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a>* _lf_more_tokens_with_ref_count = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01fd0d1404992f7d875791a764a26925" name="a01fd0d1404992f7d875791a764a26925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fd0d1404992f7d875791a764a26925">&#9670;&nbsp;</a></span>_lf_number_of_workers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int _lf_number_of_workers = 0u</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The number of worker threads for threaded execution. By default, execution is not threaded and this variable will have value 0.</p>
<p >If the execution is threaded, a value of 0 indicates that the runtime should decide on the number of workers (which will be decided based on the number of available cores on the host machine). </p>

</div>
</div>
<a id="af4b5bfd131da48f0fb95eab14e6e61c8" name="af4b5bfd131da48f0fb95eab14e6e61c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b5bfd131da48f0fb95eab14e6e61c8">&#9670;&nbsp;</a></span>_lf_reactors_to_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structallocation__record__t.html">allocation_record_t</a>* _lf_reactors_to_free = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Head of a list of pointers to dynamically generated reactor self structs to be freed in terminate(). </p>

</div>
</div>
<a id="a1211ca2b5b848ae700471d1ab0177709" name="a1211ca2b5b848ae700471d1ab0177709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1211ca2b5b848ae700471d1ab0177709">&#9670;&nbsp;</a></span>_lf_startup_reactions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreaction__t.html">reaction_t</a>** _lf_startup_reactions</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Array of pointers to all startup reactions in the program. </p>

</div>
</div>
<a id="a565a9ac648fb05c803b1d7fffe2dedd2" name="a565a9ac648fb05c803b1d7fffe2dedd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565a9ac648fb05c803b1d7fffe2dedd2">&#9670;&nbsp;</a></span>_lf_startup_reactions_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_startup_reactions_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e3d09c9be6e01e4f3e7610ef696d04c" name="a0e3d09c9be6e01e4f3e7610ef696d04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3d09c9be6e01e4f3e7610ef696d04c">&#9670;&nbsp;</a></span>_lf_token_recycling_bin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a>* _lf_token_recycling_bin = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tokens always have the same size in memory so they are easily recycled. When a token is freed, this pointer will be updated to point to it. Freed tokens are chained using their next_free field. </p>

</div>
</div>
<a id="a36d4f18784a333cacd808c3b5927eff4" name="a36d4f18784a333cacd808c3b5927eff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d4f18784a333cacd808c3b5927eff4">&#9670;&nbsp;</a></span>_lf_token_recycling_bin_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_token_recycling_bin_size = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Count of the number of tokens in the recycling bin. </p>

</div>
</div>
<a id="a3e8e15db9bf3b081c3f084d1e1a3b043" name="a3e8e15db9bf3b081c3f084d1e1a3b043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8e15db9bf3b081c3f084d1e1a3b043">&#9670;&nbsp;</a></span>_lf_tokens_with_ref_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtoken__present__t.html">token_present_t</a>* _lf_tokens_with_ref_count = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bf357e4cd193ba66ac15262992e2a9b" name="a0bf357e4cd193ba66ac15262992e2a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf357e4cd193ba66ac15262992e2a9b">&#9670;&nbsp;</a></span>_lf_tokens_with_ref_count_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_tokens_with_ref_count_size = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab46895a3a4d1341a19b689a0ea902d1" name="aab46895a3a4d1341a19b689a0ea902d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab46895a3a4d1341a19b689a0ea902d1">&#9670;&nbsp;</a></span>default_argc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int default_argc = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a079c42a8611d008395dba5af4911e85c" name="a079c42a8611d008395dba5af4911e85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079c42a8611d008395dba5af4911e85c">&#9670;&nbsp;</a></span>default_argv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** default_argv = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8079fdfadf07cba8a660c9c25cb9dc77" name="a8079fdfadf07cba8a660c9c25cb9dc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8079fdfadf07cba8a660c9c25cb9dc77">&#9670;&nbsp;</a></span>duration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a> duration = -1LL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The logical time to elapse during execution, or -1 if no timeout time has been given. When the logical equal to start_time + duration has been reached, execution will terminate. </p>

</div>
</div>
<a id="a5336de38071181906a15eccf873858fe" name="a5336de38071181906a15eccf873858fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5336de38071181906a15eccf873858fe">&#9670;&nbsp;</a></span>event_q</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpqueue__t.html">pqueue_t</a>* event_q</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Priority queues. </p>

</div>
</div>
<a id="a9c91e5c84c3910df17c909ccdea074db" name="a9c91e5c84c3910df17c909ccdea074db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c91e5c84c3910df17c909ccdea074db">&#9670;&nbsp;</a></span>fast</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> fast = <a class="el" href="lf__windows__support_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Runtime infrastructure for the C target of Lingua Franca. This file contains resources that are shared by the threaded and non-threaded versions of the C runtime.</p>
<dl class="section author"><dt>Author</dt><dd>{Edward A. Lee <a href="#" onclick="location.href='mai'+'lto:'+'eal'+'@b'+'erk'+'el'+'ey.'+'ed'+'u'; return false;">eal@b<span class="obfuscator">.nosp@m.</span>erke<span class="obfuscator">.nosp@m.</span>ley.e<span class="obfuscator">.nosp@m.</span>du</a>} </dd>
<dd>
{Marten Lohstroh <a href="#" onclick="location.href='mai'+'lto:'+'mar'+'te'+'n@b'+'er'+'kel'+'ey'+'.ed'+'u'; return false;">marte<span class="obfuscator">.nosp@m.</span>n@be<span class="obfuscator">.nosp@m.</span>rkele<span class="obfuscator">.nosp@m.</span>y.ed<span class="obfuscator">.nosp@m.</span>u</a>} </dd>
<dd>
{Mehrdad Niknami <a href="#" onclick="location.href='mai'+'lto:'+'mni'+'kn'+'ami'+'@b'+'erk'+'el'+'ey.'+'ed'+'u'; return false;">mnikn<span class="obfuscator">.nosp@m.</span>ami@<span class="obfuscator">.nosp@m.</span>berke<span class="obfuscator">.nosp@m.</span>ley.<span class="obfuscator">.nosp@m.</span>edu</a>} </dd>
<dd>
{Soroush Bateni &lt;<a href="#" onclick="location.href='mai'+'lto:'+'sor'+'ou'+'sh@'+'ut'+'dal'+'la'+'s.e'+'du'; return false;">sorou<span class="obfuscator">.nosp@m.</span>sh@u<span class="obfuscator">.nosp@m.</span>tdall<span class="obfuscator">.nosp@m.</span>as.e<span class="obfuscator">.nosp@m.</span>du</a>} </dd>
<dd>
{Alexander Schulz-Rosengarten <a href="#" onclick="location.href='mai'+'lto:'+'als'+'@i'+'nfo'+'rm'+'ati'+'k.'+'uni'+'-k'+'iel'+'.d'+'e'; return false;">als@i<span class="obfuscator">.nosp@m.</span>nfor<span class="obfuscator">.nosp@m.</span>matik<span class="obfuscator">.nosp@m.</span>.uni<span class="obfuscator">.nosp@m.</span>-kiel<span class="obfuscator">.nosp@m.</span>.de</a>} Indicator of whether to wait for physical time to match logical time. By default, execution will wait. The command-line argument -fast will eliminate the wait and allow logical time to exceed physical time. </dd></dl>

</div>
</div>
<a id="a3e69bf5802b3968ed00af688cc7a8006" name="a3e69bf5802b3968ed00af688cc7a8006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e69bf5802b3968ed00af688cc7a8006">&#9670;&nbsp;</a></span>keepalive_specified</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lf__windows__support_8h.html#a6ab4028eed8039b6a81740c40097581e">bool</a> keepalive_specified = <a class="el" href="lf__windows__support_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Indicator of whether the keepalive command-line option was given. </p>

</div>
</div>
<a id="a3015ddee9b93cc02c05fd721efb528a4" name="a3015ddee9b93cc02c05fd721efb528a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3015ddee9b93cc02c05fd721efb528a4">&#9670;&nbsp;</a></span>next_q</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpqueue__t.html">pqueue_t</a>* next_q</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a209e679d16efc35de4ffc5e1c68bafdf" name="a209e679d16efc35de4ffc5e1c68bafdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209e679d16efc35de4ffc5e1c68bafdf">&#9670;&nbsp;</a></span>recycle_q</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpqueue__t.html">pqueue_t</a>* recycle_q</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a007aadaac39cca4ce69656a91b5e236c" name="a007aadaac39cca4ce69656a91b5e236c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007aadaac39cca4ce69656a91b5e236c">&#9670;&nbsp;</a></span>stop_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> stop_tag = <a class="el" href="tag_8h.html#a33ccb2b8fb9f20ab29ea298b9051443a">FOREVER_TAG_INITIALIZER</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The tag at which the Lingua Franca program should stop. It will be initially set to timeout if it is set. However, starvation or calling <a class="el" href="reactor_8c.html#af629769c213699f0e4c9360811ee7251">request_stop()</a> can also alter the stop_tag by moving it earlier.</p>
<p >FIXME: This variable might need to be volatile </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
