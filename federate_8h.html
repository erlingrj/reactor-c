<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: include/core/federated/federate.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">reactor-c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_3d69f64eaf81436fe2b22361382717e5.html">core</a></li><li class="navelem"><a class="el" href="dir_fdacdff5c3e9d6e52f439c05e95a860d.html">federated</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">federate.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="tag_8h_source.html">tag.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lf__types_8h_source.html">lf_types.h</a>&quot;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div>
<p><a href="federate_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfederate__instance__t.html">federate_instance_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfederation__metadata__t.html">federation_metadata_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2312893474cb0415e16af40b1de063ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#a2312893474cb0415e16af40b1de063ca">ADVANCE_MESSAGE_INTERVAL</a>&#160;&#160;&#160;<a class="el" href="tag_8h.html#a673a8ebab8ec621a1cf731871dd170c8">MSEC</a>(10)</td></tr>
<tr class="separator:a2312893474cb0415e16af40b1de063ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a675c841ec6a29e45cacc71b61ef8d270"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfederate__instance__t.html">federate_instance_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#a675c841ec6a29e45cacc71b61ef8d270">federate_instance_t</a></td></tr>
<tr class="separator:a675c841ec6a29e45cacc71b61ef8d270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae335f4cb4e7d5e88ed712be8cf9592ac"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfederation__metadata__t.html">federation_metadata_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#ae335f4cb4e7d5e88ed712be8cf9592ac">federation_metadata_t</a></td></tr>
<tr class="separator:ae335f4cb4e7d5e88ed712be8cf9592ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a290fff2ff01f301f1b7b3b98fc11f492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#a290fff2ff01f301f1b7b3b98fc11f492">send_neighbor_structure_to_RTI</a> (int)</td></tr>
<tr class="separator:a290fff2ff01f301f1b7b3b98fc11f492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3a769ec47609bd5cb9fc44d51e48a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#a3e3a769ec47609bd5cb9fc44d51e48a4">connect_to_federate</a> (uint16_t)</td></tr>
<tr class="separator:a3e3a769ec47609bd5cb9fc44d51e48a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfded0ac14ed1d7a4de9a5f04870c20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#addfded0ac14ed1d7a4de9a5f04870c20">_lf_logical_tag_complete</a> (<a class="el" href="structtag__t.html">tag_t</a>)</td></tr>
<tr class="separator:addfded0ac14ed1d7a4de9a5f04870c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ddbf51d107ecd60890fef2193507a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#ab3ddbf51d107ecd60890fef2193507a4">connect_to_rti</a> (const char *, int)</td></tr>
<tr class="separator:ab3ddbf51d107ecd60890fef2193507a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f916a56b87eb98b5ad2f7aab404a550"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#a9f916a56b87eb98b5ad2f7aab404a550">listen_to_federates</a> (void *)</td></tr>
<tr class="separator:a9f916a56b87eb98b5ad2f7aab404a550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2425b519aae66167fbf454f896df92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#a0e2425b519aae66167fbf454f896df92">create_server</a> (int specified_port)</td></tr>
<tr class="separator:a0e2425b519aae66167fbf454f896df92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71f6bcab18122c661af9c5d02be4602"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#ad71f6bcab18122c661af9c5d02be4602">handle_p2p_connections_from_federates</a> (void *)</td></tr>
<tr class="separator:ad71f6bcab18122c661af9c5d02be4602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d1ca9ebfd977b64690de60b497f644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#ab5d1ca9ebfd977b64690de60b497f644">send_port_absent_to_federate</a> (<a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>, unsigned short, unsigned short)</td></tr>
<tr class="separator:ab5d1ca9ebfd977b64690de60b497f644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f0bc068b7a7c4a30983172eea59767"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#a76f0bc068b7a7c4a30983172eea59767">send_message</a> (int message_type, unsigned short port, unsigned short federate, const char *next_destination_str, size_t length, unsigned char *message)</td></tr>
<tr class="separator:a76f0bc068b7a7c4a30983172eea59767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fe0dece46300b6b9b9b59126d5f050"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#ac4fe0dece46300b6b9b9b59126d5f050">send_timed_message</a> (<a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>, int, unsigned short, unsigned short, const char *, size_t, unsigned char *)</td></tr>
<tr class="separator:ac4fe0dece46300b6b9b9b59126d5f050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1050d75d3d2a6a00effec4e07d7ad031"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#a1050d75d3d2a6a00effec4e07d7ad031">synchronize_with_other_federates</a> (void)</td></tr>
<tr class="separator:a1050d75d3d2a6a00effec4e07d7ad031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64023b2373d1b7d76435afb2dcbf41a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#a64023b2373d1b7d76435afb2dcbf41a5">wait_until_port_status_known</a> (int portID, <a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> STAA)</td></tr>
<tr class="separator:a64023b2373d1b7d76435afb2dcbf41a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1de2c61d36e14fae8de7043ff2661a34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ad7c2ee72327071ecc11ecb5787fc4a37">lf_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#a1de2c61d36e14fae8de7043ff2661a34">outbound_socket_mutex</a></td></tr>
<tr class="separator:a1de2c61d36e14fae8de7043ff2661a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31c3ee54cd862c9381fbf980fa7d9ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__cond__t.html">lf_cond_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html#ac31c3ee54cd862c9381fbf980fa7d9ef">port_status_changed</a></td></tr>
<tr class="separator:ac31c3ee54cd862c9381fbf980fa7d9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Edward A. Lee (<a href="#" onclick="location.href='mai'+'lto:'+'eal'+'@b'+'erk'+'el'+'ey.'+'ed'+'u'; return false;">eal@b<span class="obfuscator">.nosp@m.</span>erke<span class="obfuscator">.nosp@m.</span>ley.e<span class="obfuscator">.nosp@m.</span>du</a>)</dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>Copyright (c) 2020, The University of California at Berkeley.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Data structures and functions used and defined in <a class="el" href="federate_8c.html">federate.c</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2312893474cb0415e16af40b1de063ca" name="a2312893474cb0415e16af40b1de063ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2312893474cb0415e16af40b1de063ca">&#9670;&#160;</a></span>ADVANCE_MESSAGE_INTERVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADVANCE_MESSAGE_INTERVAL&#160;&#160;&#160;<a class="el" href="tag_8h.html#a673a8ebab8ec621a1cf731871dd170c8">MSEC</a>(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a675c841ec6a29e45cacc71b61ef8d270" name="a675c841ec6a29e45cacc71b61ef8d270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675c841ec6a29e45cacc71b61ef8d270">&#9670;&#160;</a></span>federate_instance_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfederate__instance__t.html">federate_instance_t</a> <a class="el" href="structfederate__instance__t.html">federate_instance_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Structure that a federate instance uses to keep track of its own state. </p>

</div>
</div>
<a id="ae335f4cb4e7d5e88ed712be8cf9592ac" name="ae335f4cb4e7d5e88ed712be8cf9592ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae335f4cb4e7d5e88ed712be8cf9592ac">&#9670;&#160;</a></span>federation_metadata_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfederation__metadata__t.html">federation_metadata_t</a> <a class="el" href="structfederation__metadata__t.html">federation_metadata_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="addfded0ac14ed1d7a4de9a5f04870c20" name="addfded0ac14ed1d7a4de9a5f04870c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfded0ac14ed1d7a4de9a5f04870c20">&#9670;&#160;</a></span>_lf_logical_tag_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_logical_tag_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a logical tag complete (LTC) message to the RTI unless an equal or later LTC has previously been sent. This function assumes the caller holds the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag_to_send</td><td>The tag to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e3a769ec47609bd5cb9fc44d51e48a4" name="a3e3a769ec47609bd5cb9fc44d51e48a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3a769ec47609bd5cb9fc44d51e48a4">&#9670;&#160;</a></span>connect_to_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connect_to_federate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect to the federate with the specified id. This established connection will then be used in functions such as <a class="el" href="federate_8h.html#ac4fe0dece46300b6b9b9b59126d5f050">send_timed_message()</a> to send messages directly to the specified federate. This function first sends an MSG_TYPE_ADDRESS_QUERY message to the RTI to obtain the IP address and port number of the specified federate. It then attempts to establish a socket connection to the specified federate. If this fails, the program exits. If it succeeds, it sets element [id] of the _fed.sockets_for_outbound_p2p_connections global array to refer to the socket for communicating directly with the federate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_federate_id</td><td>The ID of the remote federate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3ddbf51d107ecd60890fef2193507a4" name="ab3ddbf51d107ecd60890fef2193507a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ddbf51d107ecd60890fef2193507a4">&#9670;&#160;</a></span>connect_to_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connect_to_rti </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect to the RTI at the specified host and port and return the socket descriptor for the connection. If this fails, the program exits. If it succeeds, it sets the _fed.socket_TCP_RTI global variable to refer to the socket for communicating with the RTI. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>A hostname, such as "localhost". </td></tr>
    <tr><td class="paramname">port_number</td><td>A port number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e2425b519aae66167fbf454f896df92" name="a0e2425b519aae66167fbf454f896df92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2425b519aae66167fbf454f896df92">&#9670;&#160;</a></span>create_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void create_server </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>specified_port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a server to listen to incoming physical connections from remote federates. This function only handles the creation of the server socket. The reserved port for the server socket is then sent to the RTI by sending an MSG_TYPE_ADDRESS_ADVERTISEMENT message (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html">net_common.h</a>). This function expects no response from the RTI.</dd></dl>
<p>If a port is specified by the user, that will be used as the only possibility for the server. This function will fail if that port is not available. If a port is not specified, the STARTING_PORT (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html">net_common.h</a>) will be used. The function will keep incrementing the port in this case until the number of tries reaches <a class="el" href="net__common_8h.html#aff81692fc67e6f7838d9d1cff402d7f6">PORT_RANGE_LIMIT</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is similar to create_server(...) in <a class="el" href="rti_8c.html">rti.c</a>. However, it contains specific log messages for the peer to peer connections between federates. It also additionally sends an address advertisement (MSG_TYPE_ADDRESS_ADVERTISEMENT) message to the RTI informing it of the port.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">specified_port</td><td>The specified port by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad71f6bcab18122c661af9c5d02be4602" name="ad71f6bcab18122c661af9c5d02be4602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71f6bcab18122c661af9c5d02be4602">&#9670;&#160;</a></span>handle_p2p_connections_from_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * handle_p2p_connections_from_federates </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread to accept connections from other federates that send this federate messages directly (not through the RTI). This thread starts a thread for each accepted socket connection and, once it has opened all expected sockets, exits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignored</td><td>No argument needed for this thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f916a56b87eb98b5ad2f7aab404a550" name="a9f916a56b87eb98b5ad2f7aab404a550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f916a56b87eb98b5ad2f7aab404a550">&#9670;&#160;</a></span>listen_to_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * listen_to_federates </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread that listens for inputs from other federates. This thread listens for messages of type MSG_TYPE_P2P_MESSAGE, MSG_TYPE_P2P_TAGGED_MESSAGE, or MSG_TYPE_PORT_ABSENT (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html">net_common.h</a>) from the specified peer federate and calls the appropriate handling function <a class="el" href="hashmap_8h.html#a611d52c77a8144080f7bfb45eaec2a66">for</a> each message type. If an <a class="el" href="util_8h.html#a4866b2d37ffc80c5ba705d3fcd1e0ecf">error</a> occurs or an EOF is received from the peer, then this procedure sets the corresponding socket in _fed.sockets_for_inbound_p2p_connections to -1 and returns, terminating the thread. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed_id_ptr</td><td>A pointer to a uint16_t containing federate ID being listened to. This procedure frees the memory pointed to before returning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76f0bc068b7a7c4a30983172eea59767" name="a76f0bc068b7a7c4a30983172eea59767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f0bc068b7a7c4a30983172eea59767">&#9670;&#160;</a></span>send_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int send_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>message_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>federate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>next_destination_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a message to another federate directly or via the RTI. This method assumes that the caller does not hold the outbound_socket_mutex lock, which it acquires to perform the send.</p>
<p>If the socket connection to the remote federate or the RTI has been broken, then this returns 0 without sending. Otherwise, it returns 1.</p>
<dl class="section note"><dt>Note</dt><dd>This function is similar to <a class="el" href="federate_8h.html#ac4fe0dece46300b6b9b9b59126d5f050">send_timed_message()</a> except that it does not deal with time and timed_messages.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_type</td><td>The type of the message being sent. Currently can be MSG_TYPE_TAGGED_MESSAGE for messages sent via RTI or MSG_TYPE_P2P_TAGGED_MESSAGE for messages sent between federates. </td></tr>
    <tr><td class="paramname">port</td><td>The ID of the destination port. </td></tr>
    <tr><td class="paramname">federate</td><td>The ID of the destination federate. </td></tr>
    <tr><td class="paramname">next_destination_str</td><td>The name of the next destination in string format </td></tr>
    <tr><td class="paramname">length</td><td>The message length. </td></tr>
    <tr><td class="paramname">message</td><td>The message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the message has been sent, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a290fff2ff01f301f1b7b3b98fc11f492" name="a290fff2ff01f301f1b7b3b98fc11f492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290fff2ff01f301f1b7b3b98fc11f492">&#9670;&#160;</a></span>send_neighbor_structure_to_RTI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_neighbor_structure_to_RTI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generated function that sends information about connections between this federate and other federates where messages are routed through the RTI. Currently, this only includes logical connections when the coordination is centralized. This information is needed for the RTI to perform the centralized coordination. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html#a48ec489cb1543b161c262f4bee6c9598">MSG_TYPE_NEIGHBOR_STRUCTURE</a> in <a class="el" href="net__common_8h.html">net_common.h</a> </dd></dl>

</div>
</div>
<a id="ab5d1ca9ebfd977b64690de60b497f644" name="ab5d1ca9ebfd977b64690de60b497f644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d1ca9ebfd977b64690de60b497f644">&#9670;&#160;</a></span>send_port_absent_to_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_port_absent_to_federate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a port absent message to federate with fed_ID, informing the remote federate that the current federate will not produce an event on this network port at the current logical time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">additional_delay</td><td>The offset applied to the timestamp using after. The additional delay will be greater or equal to zero if an after is used on the connection. If no after is given in the program, -1 is passed. </td></tr>
    <tr><td class="paramname">port_ID</td><td>The ID of the receiving port. </td></tr>
    <tr><td class="paramname">fed_ID</td><td>The fed ID of the receiving federate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4fe0dece46300b6b9b9b59126d5f050" name="ac4fe0dece46300b6b9b9b59126d5f050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4fe0dece46300b6b9b9b59126d5f050">&#9670;&#160;</a></span>send_timed_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int send_timed_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send the specified timestamped message to the specified port in the specified federate via the RTI or directly to a federate depending on the given socket. The timestamp is calculated as current_logical_time + additional delay which is greater than or equal to zero. The port should be an input port of a reactor in the destination federate. This version does include the timestamp in the message. The caller can reuse or free the memory after this returns.</p>
<p>If the socket connection to the remote federate or the RTI has been broken, then this returns 0 without sending. Otherwise, it returns 1.</p>
<p>This method assumes that the caller does not hold the outbound_socket_mutex lock, which it acquires to perform the send.</p>
<dl class="section note"><dt>Note</dt><dd>This function is similar to <a class="el" href="federate_8h.html#a76f0bc068b7a7c4a30983172eea59767">send_message()</a> except that it sends timed messages and also contains logics related to time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">additional_delay</td><td>The offset applied to the timestamp using after. The additional delay will be greater or equal to zero if an after is used on the connection. If no after is given in the program, -1 is passed. </td></tr>
    <tr><td class="paramname">message_type</td><td>The type of the message being sent. Currently can be MSG_TYPE_TAGGED_MESSAGE for messages sent via RTI or MSG_TYPE_P2P_TAGGED_MESSAGE for messages sent between federates. </td></tr>
    <tr><td class="paramname">port</td><td>The ID of the destination port. </td></tr>
    <tr><td class="paramname">federate</td><td>The ID of the destination federate. </td></tr>
    <tr><td class="paramname">next_destination_str</td><td>The next destination in string format (RTI or federate) (used for reporting errors). </td></tr>
    <tr><td class="paramname">length</td><td>The message length. </td></tr>
    <tr><td class="paramname">message</td><td>The message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the message has been sent, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a1050d75d3d2a6a00effec4e07d7ad031" name="a1050d75d3d2a6a00effec4e07d7ad031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1050d75d3d2a6a00effec4e07d7ad031">&#9670;&#160;</a></span>synchronize_with_other_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void synchronize_with_other_federates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize the start with other federates via the RTI. This assumes that a connection to the RTI is already made and _lf_rti_socket_TCP is valid. It then sends the current logical time to the RTI and waits for the RTI to respond with a specified time. It starts a thread to listen for messages from the RTI. It then waits for physical time to match the specified time, sets current logical time to the time returned by the RTI, and then returns. If &ndash;fast was specified, then this does not wait for physical time to match the logical start time returned by the RTI. </p>

</div>
</div>
<a id="a64023b2373d1b7d76435afb2dcbf41a5" name="a64023b2373d1b7d76435afb2dcbf41a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64023b2373d1b7d76435afb2dcbf41a5">&#9670;&#160;</a></span>wait_until_port_status_known()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait_until_port_status_known </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>STAA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait until the status of network port "port_ID" is known.</p>
<p>In decentralized coordination mode, the wait time is capped by STAA + STA, after which the status of the port is presumed to be absent.</p>
<p>This function assumes the holder does not hold a mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_ID</td><td>The ID of the network port </td></tr>
    <tr><td class="paramname">STAA</td><td>The safe-to-assume-absent threshold for the port </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1de2c61d36e14fae8de7043ff2661a34" name="a1de2c61d36e14fae8de7043ff2661a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de2c61d36e14fae8de7043ff2661a34">&#9670;&#160;</a></span>outbound_socket_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ad7c2ee72327071ecc11ecb5787fc4a37">lf_mutex_t</a> outbound_socket_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac31c3ee54cd862c9381fbf980fa7d9ef" name="ac31c3ee54cd862c9381fbf980fa7d9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31c3ee54cd862c9381fbf980fa7d9ef">&#9670;&#160;</a></span>port_status_changed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__cond__t.html">lf_cond_t</a> port_status_changed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
